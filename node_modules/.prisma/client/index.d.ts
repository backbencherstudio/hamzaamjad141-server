
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Ucode
 * 
 */
export type Ucode = $Result.DefaultSelection<Prisma.$UcodePayload>
/**
 * Model UserNewMember
 * 
 */
export type UserNewMember = $Result.DefaultSelection<Prisma.$UserNewMemberPayload>
/**
 * Model Instructor
 * 
 */
export type Instructor = $Result.DefaultSelection<Prisma.$InstructorPayload>
/**
 * Model UserInstructor
 * 
 */
export type UserInstructor = $Result.DefaultSelection<Prisma.$UserInstructorPayload>
/**
 * Model AddLog
 * 
 */
export type AddLog = $Result.DefaultSelection<Prisma.$AddLogPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model PilotWeather
 * 
 */
export type PilotWeather = $Result.DefaultSelection<Prisma.$PilotWeatherPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Licese: {
  NO_LICENCE: 'NO_LICENCE',
  SPL: 'SPL',
  PPL: 'PPL',
  CPL: 'CPL',
  ATPL: 'ATPL',
  CH: 'CH'
};

export type Licese = (typeof Licese)[keyof typeof Licese]


export const Action: {
  active: 'active',
  inactive: 'inactive'
};

export type Action = (typeof Action)[keyof typeof Action]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Licese = $Enums.Licese

export const Licese: typeof $Enums.Licese

export type Action = $Enums.Action

export const Action: typeof $Enums.Action

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ucode`: Exposes CRUD operations for the **Ucode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ucodes
    * const ucodes = await prisma.ucode.findMany()
    * ```
    */
  get ucode(): Prisma.UcodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userNewMember`: Exposes CRUD operations for the **UserNewMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserNewMembers
    * const userNewMembers = await prisma.userNewMember.findMany()
    * ```
    */
  get userNewMember(): Prisma.UserNewMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.instructor`: Exposes CRUD operations for the **Instructor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instructors
    * const instructors = await prisma.instructor.findMany()
    * ```
    */
  get instructor(): Prisma.InstructorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userInstructor`: Exposes CRUD operations for the **UserInstructor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserInstructors
    * const userInstructors = await prisma.userInstructor.findMany()
    * ```
    */
  get userInstructor(): Prisma.UserInstructorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addLog`: Exposes CRUD operations for the **AddLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddLogs
    * const addLogs = await prisma.addLog.findMany()
    * ```
    */
  get addLog(): Prisma.AddLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pilotWeather`: Exposes CRUD operations for the **PilotWeather** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PilotWeathers
    * const pilotWeathers = await prisma.pilotWeather.findMany()
    * ```
    */
  get pilotWeather(): Prisma.PilotWeatherDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Ucode: 'Ucode',
    UserNewMember: 'UserNewMember',
    Instructor: 'Instructor',
    UserInstructor: 'UserInstructor',
    AddLog: 'AddLog',
    Location: 'Location',
    PilotWeather: 'PilotWeather'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "ucode" | "userNewMember" | "instructor" | "userInstructor" | "addLog" | "location" | "pilotWeather"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Ucode: {
        payload: Prisma.$UcodePayload<ExtArgs>
        fields: Prisma.UcodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UcodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UcodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UcodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UcodePayload>
          }
          findFirst: {
            args: Prisma.UcodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UcodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UcodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UcodePayload>
          }
          findMany: {
            args: Prisma.UcodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UcodePayload>[]
          }
          create: {
            args: Prisma.UcodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UcodePayload>
          }
          createMany: {
            args: Prisma.UcodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UcodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UcodePayload>[]
          }
          delete: {
            args: Prisma.UcodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UcodePayload>
          }
          update: {
            args: Prisma.UcodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UcodePayload>
          }
          deleteMany: {
            args: Prisma.UcodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UcodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UcodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UcodePayload>[]
          }
          upsert: {
            args: Prisma.UcodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UcodePayload>
          }
          aggregate: {
            args: Prisma.UcodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUcode>
          }
          groupBy: {
            args: Prisma.UcodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UcodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UcodeCountArgs<ExtArgs>
            result: $Utils.Optional<UcodeCountAggregateOutputType> | number
          }
        }
      }
      UserNewMember: {
        payload: Prisma.$UserNewMemberPayload<ExtArgs>
        fields: Prisma.UserNewMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserNewMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNewMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserNewMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNewMemberPayload>
          }
          findFirst: {
            args: Prisma.UserNewMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNewMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserNewMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNewMemberPayload>
          }
          findMany: {
            args: Prisma.UserNewMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNewMemberPayload>[]
          }
          create: {
            args: Prisma.UserNewMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNewMemberPayload>
          }
          createMany: {
            args: Prisma.UserNewMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserNewMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNewMemberPayload>[]
          }
          delete: {
            args: Prisma.UserNewMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNewMemberPayload>
          }
          update: {
            args: Prisma.UserNewMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNewMemberPayload>
          }
          deleteMany: {
            args: Prisma.UserNewMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserNewMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserNewMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNewMemberPayload>[]
          }
          upsert: {
            args: Prisma.UserNewMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNewMemberPayload>
          }
          aggregate: {
            args: Prisma.UserNewMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserNewMember>
          }
          groupBy: {
            args: Prisma.UserNewMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserNewMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserNewMemberCountArgs<ExtArgs>
            result: $Utils.Optional<UserNewMemberCountAggregateOutputType> | number
          }
        }
      }
      Instructor: {
        payload: Prisma.$InstructorPayload<ExtArgs>
        fields: Prisma.InstructorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstructorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstructorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>
          }
          findFirst: {
            args: Prisma.InstructorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstructorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>
          }
          findMany: {
            args: Prisma.InstructorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>[]
          }
          create: {
            args: Prisma.InstructorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>
          }
          createMany: {
            args: Prisma.InstructorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstructorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>[]
          }
          delete: {
            args: Prisma.InstructorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>
          }
          update: {
            args: Prisma.InstructorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>
          }
          deleteMany: {
            args: Prisma.InstructorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstructorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstructorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>[]
          }
          upsert: {
            args: Prisma.InstructorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>
          }
          aggregate: {
            args: Prisma.InstructorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstructor>
          }
          groupBy: {
            args: Prisma.InstructorGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstructorGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstructorCountArgs<ExtArgs>
            result: $Utils.Optional<InstructorCountAggregateOutputType> | number
          }
        }
      }
      UserInstructor: {
        payload: Prisma.$UserInstructorPayload<ExtArgs>
        fields: Prisma.UserInstructorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserInstructorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInstructorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserInstructorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInstructorPayload>
          }
          findFirst: {
            args: Prisma.UserInstructorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInstructorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserInstructorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInstructorPayload>
          }
          findMany: {
            args: Prisma.UserInstructorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInstructorPayload>[]
          }
          create: {
            args: Prisma.UserInstructorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInstructorPayload>
          }
          createMany: {
            args: Prisma.UserInstructorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserInstructorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInstructorPayload>[]
          }
          delete: {
            args: Prisma.UserInstructorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInstructorPayload>
          }
          update: {
            args: Prisma.UserInstructorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInstructorPayload>
          }
          deleteMany: {
            args: Prisma.UserInstructorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserInstructorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserInstructorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInstructorPayload>[]
          }
          upsert: {
            args: Prisma.UserInstructorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInstructorPayload>
          }
          aggregate: {
            args: Prisma.UserInstructorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserInstructor>
          }
          groupBy: {
            args: Prisma.UserInstructorGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserInstructorGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserInstructorCountArgs<ExtArgs>
            result: $Utils.Optional<UserInstructorCountAggregateOutputType> | number
          }
        }
      }
      AddLog: {
        payload: Prisma.$AddLogPayload<ExtArgs>
        fields: Prisma.AddLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddLogPayload>
          }
          findFirst: {
            args: Prisma.AddLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddLogPayload>
          }
          findMany: {
            args: Prisma.AddLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddLogPayload>[]
          }
          create: {
            args: Prisma.AddLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddLogPayload>
          }
          createMany: {
            args: Prisma.AddLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddLogPayload>[]
          }
          delete: {
            args: Prisma.AddLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddLogPayload>
          }
          update: {
            args: Prisma.AddLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddLogPayload>
          }
          deleteMany: {
            args: Prisma.AddLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddLogPayload>[]
          }
          upsert: {
            args: Prisma.AddLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddLogPayload>
          }
          aggregate: {
            args: Prisma.AddLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddLog>
          }
          groupBy: {
            args: Prisma.AddLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddLogCountArgs<ExtArgs>
            result: $Utils.Optional<AddLogCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      PilotWeather: {
        payload: Prisma.$PilotWeatherPayload<ExtArgs>
        fields: Prisma.PilotWeatherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PilotWeatherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PilotWeatherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PilotWeatherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PilotWeatherPayload>
          }
          findFirst: {
            args: Prisma.PilotWeatherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PilotWeatherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PilotWeatherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PilotWeatherPayload>
          }
          findMany: {
            args: Prisma.PilotWeatherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PilotWeatherPayload>[]
          }
          create: {
            args: Prisma.PilotWeatherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PilotWeatherPayload>
          }
          createMany: {
            args: Prisma.PilotWeatherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PilotWeatherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PilotWeatherPayload>[]
          }
          delete: {
            args: Prisma.PilotWeatherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PilotWeatherPayload>
          }
          update: {
            args: Prisma.PilotWeatherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PilotWeatherPayload>
          }
          deleteMany: {
            args: Prisma.PilotWeatherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PilotWeatherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PilotWeatherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PilotWeatherPayload>[]
          }
          upsert: {
            args: Prisma.PilotWeatherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PilotWeatherPayload>
          }
          aggregate: {
            args: Prisma.PilotWeatherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePilotWeather>
          }
          groupBy: {
            args: Prisma.PilotWeatherGroupByArgs<ExtArgs>
            result: $Utils.Optional<PilotWeatherGroupByOutputType>[]
          }
          count: {
            args: Prisma.PilotWeatherCountArgs<ExtArgs>
            result: $Utils.Optional<PilotWeatherCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    ucode?: UcodeOmit
    userNewMember?: UserNewMemberOmit
    instructor?: InstructorOmit
    userInstructor?: UserInstructorOmit
    addLog?: AddLogOmit
    location?: LocationOmit
    pilotWeather?: PilotWeatherOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    instructor: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instructor?: boolean | UserCountOutputTypeCountInstructorArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInstructorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstructorWhereInput
  }


  /**
   * Count Type UserInstructorCountOutputType
   */

  export type UserInstructorCountOutputType = {
    addLog: number
  }

  export type UserInstructorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addLog?: boolean | UserInstructorCountOutputTypeCountAddLogArgs
  }

  // Custom InputTypes
  /**
   * UserInstructorCountOutputType without action
   */
  export type UserInstructorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInstructorCountOutputType
     */
    select?: UserInstructorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserInstructorCountOutputType without action
   */
  export type UserInstructorCountOutputTypeCountAddLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddLogWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    weather: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weather?: boolean | LocationCountOutputTypeCountWeatherArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountWeatherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PilotWeatherWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    image: string | null
    license: $Enums.Licese | null
    role: $Enums.Role | null
    authProvider: string | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    image: string | null
    license: $Enums.Licese | null
    role: $Enums.Role | null
    authProvider: string | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    image: number
    license: number
    role: number
    authProvider: number
    isVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    image?: true
    license?: true
    role?: true
    authProvider?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    image?: true
    license?: true
    role?: true
    authProvider?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    image?: true
    license?: true
    role?: true
    authProvider?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string
    password: string | null
    image: string | null
    license: $Enums.Licese
    role: $Enums.Role
    authProvider: string | null
    isVerified: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    image?: boolean
    license?: boolean
    role?: boolean
    authProvider?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instructor?: boolean | User$instructorArgs<ExtArgs>
    addLog?: boolean | User$addLogArgs<ExtArgs>
    userNewMember?: boolean | User$userNewMemberArgs<ExtArgs>
    pilotWeather?: boolean | User$pilotWeatherArgs<ExtArgs>
    userInstructor?: boolean | User$userInstructorArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    image?: boolean
    license?: boolean
    role?: boolean
    authProvider?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    image?: boolean
    license?: boolean
    role?: boolean
    authProvider?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    image?: boolean
    license?: boolean
    role?: boolean
    authProvider?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "image" | "license" | "role" | "authProvider" | "isVerified" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instructor?: boolean | User$instructorArgs<ExtArgs>
    addLog?: boolean | User$addLogArgs<ExtArgs>
    userNewMember?: boolean | User$userNewMemberArgs<ExtArgs>
    pilotWeather?: boolean | User$pilotWeatherArgs<ExtArgs>
    userInstructor?: boolean | User$userInstructorArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      instructor: Prisma.$InstructorPayload<ExtArgs>[]
      addLog: Prisma.$AddLogPayload<ExtArgs> | null
      userNewMember: Prisma.$UserNewMemberPayload<ExtArgs> | null
      pilotWeather: Prisma.$PilotWeatherPayload<ExtArgs> | null
      userInstructor: Prisma.$UserInstructorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      password: string | null
      image: string | null
      license: $Enums.Licese
      role: $Enums.Role
      authProvider: string | null
      isVerified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instructor<T extends User$instructorArgs<ExtArgs> = {}>(args?: Subset<T, User$instructorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addLog<T extends User$addLogArgs<ExtArgs> = {}>(args?: Subset<T, User$addLogArgs<ExtArgs>>): Prisma__AddLogClient<$Result.GetResult<Prisma.$AddLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userNewMember<T extends User$userNewMemberArgs<ExtArgs> = {}>(args?: Subset<T, User$userNewMemberArgs<ExtArgs>>): Prisma__UserNewMemberClient<$Result.GetResult<Prisma.$UserNewMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pilotWeather<T extends User$pilotWeatherArgs<ExtArgs> = {}>(args?: Subset<T, User$pilotWeatherArgs<ExtArgs>>): Prisma__PilotWeatherClient<$Result.GetResult<Prisma.$PilotWeatherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userInstructor<T extends User$userInstructorArgs<ExtArgs> = {}>(args?: Subset<T, User$userInstructorArgs<ExtArgs>>): Prisma__UserInstructorClient<$Result.GetResult<Prisma.$UserInstructorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly license: FieldRef<"User", 'Licese'>
    readonly role: FieldRef<"User", 'Role'>
    readonly authProvider: FieldRef<"User", 'String'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.instructor
   */
  export type User$instructorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    where?: InstructorWhereInput
    orderBy?: InstructorOrderByWithRelationInput | InstructorOrderByWithRelationInput[]
    cursor?: InstructorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstructorScalarFieldEnum | InstructorScalarFieldEnum[]
  }

  /**
   * User.addLog
   */
  export type User$addLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddLog
     */
    select?: AddLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddLog
     */
    omit?: AddLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddLogInclude<ExtArgs> | null
    where?: AddLogWhereInput
  }

  /**
   * User.userNewMember
   */
  export type User$userNewMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNewMember
     */
    select?: UserNewMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNewMember
     */
    omit?: UserNewMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNewMemberInclude<ExtArgs> | null
    where?: UserNewMemberWhereInput
  }

  /**
   * User.pilotWeather
   */
  export type User$pilotWeatherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PilotWeather
     */
    select?: PilotWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PilotWeather
     */
    omit?: PilotWeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PilotWeatherInclude<ExtArgs> | null
    where?: PilotWeatherWhereInput
  }

  /**
   * User.userInstructor
   */
  export type User$userInstructorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInstructor
     */
    select?: UserInstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInstructor
     */
    omit?: UserInstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInstructorInclude<ExtArgs> | null
    where?: UserInstructorWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Ucode
   */

  export type AggregateUcode = {
    _count: UcodeCountAggregateOutputType | null
    _avg: UcodeAvgAggregateOutputType | null
    _sum: UcodeSumAggregateOutputType | null
    _min: UcodeMinAggregateOutputType | null
    _max: UcodeMaxAggregateOutputType | null
  }

  export type UcodeAvgAggregateOutputType = {
    id: number | null
  }

  export type UcodeSumAggregateOutputType = {
    id: number | null
  }

  export type UcodeMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    image: string | null
    license: $Enums.Licese | null
    otp: string | null
    expiration: Date | null
    createdAt: Date | null
  }

  export type UcodeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    image: string | null
    license: $Enums.Licese | null
    otp: string | null
    expiration: Date | null
    createdAt: Date | null
  }

  export type UcodeCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    image: number
    license: number
    otp: number
    expiration: number
    createdAt: number
    _all: number
  }


  export type UcodeAvgAggregateInputType = {
    id?: true
  }

  export type UcodeSumAggregateInputType = {
    id?: true
  }

  export type UcodeMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    image?: true
    license?: true
    otp?: true
    expiration?: true
    createdAt?: true
  }

  export type UcodeMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    image?: true
    license?: true
    otp?: true
    expiration?: true
    createdAt?: true
  }

  export type UcodeCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    image?: true
    license?: true
    otp?: true
    expiration?: true
    createdAt?: true
    _all?: true
  }

  export type UcodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ucode to aggregate.
     */
    where?: UcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ucodes to fetch.
     */
    orderBy?: UcodeOrderByWithRelationInput | UcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ucodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ucodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ucodes
    **/
    _count?: true | UcodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UcodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UcodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UcodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UcodeMaxAggregateInputType
  }

  export type GetUcodeAggregateType<T extends UcodeAggregateArgs> = {
        [P in keyof T & keyof AggregateUcode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUcode[P]>
      : GetScalarType<T[P], AggregateUcode[P]>
  }




  export type UcodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UcodeWhereInput
    orderBy?: UcodeOrderByWithAggregationInput | UcodeOrderByWithAggregationInput[]
    by: UcodeScalarFieldEnum[] | UcodeScalarFieldEnum
    having?: UcodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UcodeCountAggregateInputType | true
    _avg?: UcodeAvgAggregateInputType
    _sum?: UcodeSumAggregateInputType
    _min?: UcodeMinAggregateInputType
    _max?: UcodeMaxAggregateInputType
  }

  export type UcodeGroupByOutputType = {
    id: number
    name: string
    email: string
    password: string
    image: string | null
    license: $Enums.Licese
    otp: string | null
    expiration: Date | null
    createdAt: Date
    _count: UcodeCountAggregateOutputType | null
    _avg: UcodeAvgAggregateOutputType | null
    _sum: UcodeSumAggregateOutputType | null
    _min: UcodeMinAggregateOutputType | null
    _max: UcodeMaxAggregateOutputType | null
  }

  type GetUcodeGroupByPayload<T extends UcodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UcodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UcodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UcodeGroupByOutputType[P]>
            : GetScalarType<T[P], UcodeGroupByOutputType[P]>
        }
      >
    >


  export type UcodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    image?: boolean
    license?: boolean
    otp?: boolean
    expiration?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["ucode"]>

  export type UcodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    image?: boolean
    license?: boolean
    otp?: boolean
    expiration?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["ucode"]>

  export type UcodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    image?: boolean
    license?: boolean
    otp?: boolean
    expiration?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["ucode"]>

  export type UcodeSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    image?: boolean
    license?: boolean
    otp?: boolean
    expiration?: boolean
    createdAt?: boolean
  }

  export type UcodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "image" | "license" | "otp" | "expiration" | "createdAt", ExtArgs["result"]["ucode"]>

  export type $UcodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ucode"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      password: string
      image: string | null
      license: $Enums.Licese
      otp: string | null
      expiration: Date | null
      createdAt: Date
    }, ExtArgs["result"]["ucode"]>
    composites: {}
  }

  type UcodeGetPayload<S extends boolean | null | undefined | UcodeDefaultArgs> = $Result.GetResult<Prisma.$UcodePayload, S>

  type UcodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UcodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UcodeCountAggregateInputType | true
    }

  export interface UcodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ucode'], meta: { name: 'Ucode' } }
    /**
     * Find zero or one Ucode that matches the filter.
     * @param {UcodeFindUniqueArgs} args - Arguments to find a Ucode
     * @example
     * // Get one Ucode
     * const ucode = await prisma.ucode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UcodeFindUniqueArgs>(args: SelectSubset<T, UcodeFindUniqueArgs<ExtArgs>>): Prisma__UcodeClient<$Result.GetResult<Prisma.$UcodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ucode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UcodeFindUniqueOrThrowArgs} args - Arguments to find a Ucode
     * @example
     * // Get one Ucode
     * const ucode = await prisma.ucode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UcodeFindUniqueOrThrowArgs>(args: SelectSubset<T, UcodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UcodeClient<$Result.GetResult<Prisma.$UcodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ucode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UcodeFindFirstArgs} args - Arguments to find a Ucode
     * @example
     * // Get one Ucode
     * const ucode = await prisma.ucode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UcodeFindFirstArgs>(args?: SelectSubset<T, UcodeFindFirstArgs<ExtArgs>>): Prisma__UcodeClient<$Result.GetResult<Prisma.$UcodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ucode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UcodeFindFirstOrThrowArgs} args - Arguments to find a Ucode
     * @example
     * // Get one Ucode
     * const ucode = await prisma.ucode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UcodeFindFirstOrThrowArgs>(args?: SelectSubset<T, UcodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UcodeClient<$Result.GetResult<Prisma.$UcodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ucodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UcodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ucodes
     * const ucodes = await prisma.ucode.findMany()
     * 
     * // Get first 10 Ucodes
     * const ucodes = await prisma.ucode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ucodeWithIdOnly = await prisma.ucode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UcodeFindManyArgs>(args?: SelectSubset<T, UcodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UcodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ucode.
     * @param {UcodeCreateArgs} args - Arguments to create a Ucode.
     * @example
     * // Create one Ucode
     * const Ucode = await prisma.ucode.create({
     *   data: {
     *     // ... data to create a Ucode
     *   }
     * })
     * 
     */
    create<T extends UcodeCreateArgs>(args: SelectSubset<T, UcodeCreateArgs<ExtArgs>>): Prisma__UcodeClient<$Result.GetResult<Prisma.$UcodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ucodes.
     * @param {UcodeCreateManyArgs} args - Arguments to create many Ucodes.
     * @example
     * // Create many Ucodes
     * const ucode = await prisma.ucode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UcodeCreateManyArgs>(args?: SelectSubset<T, UcodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ucodes and returns the data saved in the database.
     * @param {UcodeCreateManyAndReturnArgs} args - Arguments to create many Ucodes.
     * @example
     * // Create many Ucodes
     * const ucode = await prisma.ucode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ucodes and only return the `id`
     * const ucodeWithIdOnly = await prisma.ucode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UcodeCreateManyAndReturnArgs>(args?: SelectSubset<T, UcodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UcodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ucode.
     * @param {UcodeDeleteArgs} args - Arguments to delete one Ucode.
     * @example
     * // Delete one Ucode
     * const Ucode = await prisma.ucode.delete({
     *   where: {
     *     // ... filter to delete one Ucode
     *   }
     * })
     * 
     */
    delete<T extends UcodeDeleteArgs>(args: SelectSubset<T, UcodeDeleteArgs<ExtArgs>>): Prisma__UcodeClient<$Result.GetResult<Prisma.$UcodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ucode.
     * @param {UcodeUpdateArgs} args - Arguments to update one Ucode.
     * @example
     * // Update one Ucode
     * const ucode = await prisma.ucode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UcodeUpdateArgs>(args: SelectSubset<T, UcodeUpdateArgs<ExtArgs>>): Prisma__UcodeClient<$Result.GetResult<Prisma.$UcodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ucodes.
     * @param {UcodeDeleteManyArgs} args - Arguments to filter Ucodes to delete.
     * @example
     * // Delete a few Ucodes
     * const { count } = await prisma.ucode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UcodeDeleteManyArgs>(args?: SelectSubset<T, UcodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ucodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UcodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ucodes
     * const ucode = await prisma.ucode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UcodeUpdateManyArgs>(args: SelectSubset<T, UcodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ucodes and returns the data updated in the database.
     * @param {UcodeUpdateManyAndReturnArgs} args - Arguments to update many Ucodes.
     * @example
     * // Update many Ucodes
     * const ucode = await prisma.ucode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ucodes and only return the `id`
     * const ucodeWithIdOnly = await prisma.ucode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UcodeUpdateManyAndReturnArgs>(args: SelectSubset<T, UcodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UcodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ucode.
     * @param {UcodeUpsertArgs} args - Arguments to update or create a Ucode.
     * @example
     * // Update or create a Ucode
     * const ucode = await prisma.ucode.upsert({
     *   create: {
     *     // ... data to create a Ucode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ucode we want to update
     *   }
     * })
     */
    upsert<T extends UcodeUpsertArgs>(args: SelectSubset<T, UcodeUpsertArgs<ExtArgs>>): Prisma__UcodeClient<$Result.GetResult<Prisma.$UcodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ucodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UcodeCountArgs} args - Arguments to filter Ucodes to count.
     * @example
     * // Count the number of Ucodes
     * const count = await prisma.ucode.count({
     *   where: {
     *     // ... the filter for the Ucodes we want to count
     *   }
     * })
    **/
    count<T extends UcodeCountArgs>(
      args?: Subset<T, UcodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UcodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ucode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UcodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UcodeAggregateArgs>(args: Subset<T, UcodeAggregateArgs>): Prisma.PrismaPromise<GetUcodeAggregateType<T>>

    /**
     * Group by Ucode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UcodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UcodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UcodeGroupByArgs['orderBy'] }
        : { orderBy?: UcodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UcodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUcodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ucode model
   */
  readonly fields: UcodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ucode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UcodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ucode model
   */
  interface UcodeFieldRefs {
    readonly id: FieldRef<"Ucode", 'Int'>
    readonly name: FieldRef<"Ucode", 'String'>
    readonly email: FieldRef<"Ucode", 'String'>
    readonly password: FieldRef<"Ucode", 'String'>
    readonly image: FieldRef<"Ucode", 'String'>
    readonly license: FieldRef<"Ucode", 'Licese'>
    readonly otp: FieldRef<"Ucode", 'String'>
    readonly expiration: FieldRef<"Ucode", 'DateTime'>
    readonly createdAt: FieldRef<"Ucode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ucode findUnique
   */
  export type UcodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ucode
     */
    select?: UcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ucode
     */
    omit?: UcodeOmit<ExtArgs> | null
    /**
     * Filter, which Ucode to fetch.
     */
    where: UcodeWhereUniqueInput
  }

  /**
   * Ucode findUniqueOrThrow
   */
  export type UcodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ucode
     */
    select?: UcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ucode
     */
    omit?: UcodeOmit<ExtArgs> | null
    /**
     * Filter, which Ucode to fetch.
     */
    where: UcodeWhereUniqueInput
  }

  /**
   * Ucode findFirst
   */
  export type UcodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ucode
     */
    select?: UcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ucode
     */
    omit?: UcodeOmit<ExtArgs> | null
    /**
     * Filter, which Ucode to fetch.
     */
    where?: UcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ucodes to fetch.
     */
    orderBy?: UcodeOrderByWithRelationInput | UcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ucodes.
     */
    cursor?: UcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ucodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ucodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ucodes.
     */
    distinct?: UcodeScalarFieldEnum | UcodeScalarFieldEnum[]
  }

  /**
   * Ucode findFirstOrThrow
   */
  export type UcodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ucode
     */
    select?: UcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ucode
     */
    omit?: UcodeOmit<ExtArgs> | null
    /**
     * Filter, which Ucode to fetch.
     */
    where?: UcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ucodes to fetch.
     */
    orderBy?: UcodeOrderByWithRelationInput | UcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ucodes.
     */
    cursor?: UcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ucodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ucodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ucodes.
     */
    distinct?: UcodeScalarFieldEnum | UcodeScalarFieldEnum[]
  }

  /**
   * Ucode findMany
   */
  export type UcodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ucode
     */
    select?: UcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ucode
     */
    omit?: UcodeOmit<ExtArgs> | null
    /**
     * Filter, which Ucodes to fetch.
     */
    where?: UcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ucodes to fetch.
     */
    orderBy?: UcodeOrderByWithRelationInput | UcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ucodes.
     */
    cursor?: UcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ucodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ucodes.
     */
    skip?: number
    distinct?: UcodeScalarFieldEnum | UcodeScalarFieldEnum[]
  }

  /**
   * Ucode create
   */
  export type UcodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ucode
     */
    select?: UcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ucode
     */
    omit?: UcodeOmit<ExtArgs> | null
    /**
     * The data needed to create a Ucode.
     */
    data: XOR<UcodeCreateInput, UcodeUncheckedCreateInput>
  }

  /**
   * Ucode createMany
   */
  export type UcodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ucodes.
     */
    data: UcodeCreateManyInput | UcodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ucode createManyAndReturn
   */
  export type UcodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ucode
     */
    select?: UcodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ucode
     */
    omit?: UcodeOmit<ExtArgs> | null
    /**
     * The data used to create many Ucodes.
     */
    data: UcodeCreateManyInput | UcodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ucode update
   */
  export type UcodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ucode
     */
    select?: UcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ucode
     */
    omit?: UcodeOmit<ExtArgs> | null
    /**
     * The data needed to update a Ucode.
     */
    data: XOR<UcodeUpdateInput, UcodeUncheckedUpdateInput>
    /**
     * Choose, which Ucode to update.
     */
    where: UcodeWhereUniqueInput
  }

  /**
   * Ucode updateMany
   */
  export type UcodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ucodes.
     */
    data: XOR<UcodeUpdateManyMutationInput, UcodeUncheckedUpdateManyInput>
    /**
     * Filter which Ucodes to update
     */
    where?: UcodeWhereInput
    /**
     * Limit how many Ucodes to update.
     */
    limit?: number
  }

  /**
   * Ucode updateManyAndReturn
   */
  export type UcodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ucode
     */
    select?: UcodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ucode
     */
    omit?: UcodeOmit<ExtArgs> | null
    /**
     * The data used to update Ucodes.
     */
    data: XOR<UcodeUpdateManyMutationInput, UcodeUncheckedUpdateManyInput>
    /**
     * Filter which Ucodes to update
     */
    where?: UcodeWhereInput
    /**
     * Limit how many Ucodes to update.
     */
    limit?: number
  }

  /**
   * Ucode upsert
   */
  export type UcodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ucode
     */
    select?: UcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ucode
     */
    omit?: UcodeOmit<ExtArgs> | null
    /**
     * The filter to search for the Ucode to update in case it exists.
     */
    where: UcodeWhereUniqueInput
    /**
     * In case the Ucode found by the `where` argument doesn't exist, create a new Ucode with this data.
     */
    create: XOR<UcodeCreateInput, UcodeUncheckedCreateInput>
    /**
     * In case the Ucode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UcodeUpdateInput, UcodeUncheckedUpdateInput>
  }

  /**
   * Ucode delete
   */
  export type UcodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ucode
     */
    select?: UcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ucode
     */
    omit?: UcodeOmit<ExtArgs> | null
    /**
     * Filter which Ucode to delete.
     */
    where: UcodeWhereUniqueInput
  }

  /**
   * Ucode deleteMany
   */
  export type UcodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ucodes to delete
     */
    where?: UcodeWhereInput
    /**
     * Limit how many Ucodes to delete.
     */
    limit?: number
  }

  /**
   * Ucode without action
   */
  export type UcodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ucode
     */
    select?: UcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ucode
     */
    omit?: UcodeOmit<ExtArgs> | null
  }


  /**
   * Model UserNewMember
   */

  export type AggregateUserNewMember = {
    _count: UserNewMemberCountAggregateOutputType | null
    _avg: UserNewMemberAvgAggregateOutputType | null
    _sum: UserNewMemberSumAggregateOutputType | null
    _min: UserNewMemberMinAggregateOutputType | null
    _max: UserNewMemberMaxAggregateOutputType | null
  }

  export type UserNewMemberAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserNewMemberSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserNewMemberMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    subscription: string | null
    status: string | null
    action: string | null
    userId: number | null
    createdAt: Date | null
  }

  export type UserNewMemberMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    subscription: string | null
    status: string | null
    action: string | null
    userId: number | null
    createdAt: Date | null
  }

  export type UserNewMemberCountAggregateOutputType = {
    id: number
    name: number
    email: number
    subscription: number
    status: number
    action: number
    userId: number
    createdAt: number
    _all: number
  }


  export type UserNewMemberAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserNewMemberSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserNewMemberMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subscription?: true
    status?: true
    action?: true
    userId?: true
    createdAt?: true
  }

  export type UserNewMemberMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subscription?: true
    status?: true
    action?: true
    userId?: true
    createdAt?: true
  }

  export type UserNewMemberCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subscription?: true
    status?: true
    action?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type UserNewMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNewMember to aggregate.
     */
    where?: UserNewMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNewMembers to fetch.
     */
    orderBy?: UserNewMemberOrderByWithRelationInput | UserNewMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserNewMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNewMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNewMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserNewMembers
    **/
    _count?: true | UserNewMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserNewMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserNewMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserNewMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserNewMemberMaxAggregateInputType
  }

  export type GetUserNewMemberAggregateType<T extends UserNewMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateUserNewMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserNewMember[P]>
      : GetScalarType<T[P], AggregateUserNewMember[P]>
  }




  export type UserNewMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserNewMemberWhereInput
    orderBy?: UserNewMemberOrderByWithAggregationInput | UserNewMemberOrderByWithAggregationInput[]
    by: UserNewMemberScalarFieldEnum[] | UserNewMemberScalarFieldEnum
    having?: UserNewMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserNewMemberCountAggregateInputType | true
    _avg?: UserNewMemberAvgAggregateInputType
    _sum?: UserNewMemberSumAggregateInputType
    _min?: UserNewMemberMinAggregateInputType
    _max?: UserNewMemberMaxAggregateInputType
  }

  export type UserNewMemberGroupByOutputType = {
    id: number
    name: string
    email: string
    subscription: string | null
    status: string | null
    action: string | null
    userId: number
    createdAt: Date
    _count: UserNewMemberCountAggregateOutputType | null
    _avg: UserNewMemberAvgAggregateOutputType | null
    _sum: UserNewMemberSumAggregateOutputType | null
    _min: UserNewMemberMinAggregateOutputType | null
    _max: UserNewMemberMaxAggregateOutputType | null
  }

  type GetUserNewMemberGroupByPayload<T extends UserNewMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserNewMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserNewMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserNewMemberGroupByOutputType[P]>
            : GetScalarType<T[P], UserNewMemberGroupByOutputType[P]>
        }
      >
    >


  export type UserNewMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    subscription?: boolean
    status?: boolean
    action?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNewMember"]>

  export type UserNewMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    subscription?: boolean
    status?: boolean
    action?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNewMember"]>

  export type UserNewMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    subscription?: boolean
    status?: boolean
    action?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNewMember"]>

  export type UserNewMemberSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    subscription?: boolean
    status?: boolean
    action?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type UserNewMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "subscription" | "status" | "action" | "userId" | "createdAt", ExtArgs["result"]["userNewMember"]>
  export type UserNewMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserNewMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserNewMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserNewMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserNewMember"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      subscription: string | null
      status: string | null
      action: string | null
      userId: number
      createdAt: Date
    }, ExtArgs["result"]["userNewMember"]>
    composites: {}
  }

  type UserNewMemberGetPayload<S extends boolean | null | undefined | UserNewMemberDefaultArgs> = $Result.GetResult<Prisma.$UserNewMemberPayload, S>

  type UserNewMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserNewMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserNewMemberCountAggregateInputType | true
    }

  export interface UserNewMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserNewMember'], meta: { name: 'UserNewMember' } }
    /**
     * Find zero or one UserNewMember that matches the filter.
     * @param {UserNewMemberFindUniqueArgs} args - Arguments to find a UserNewMember
     * @example
     * // Get one UserNewMember
     * const userNewMember = await prisma.userNewMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserNewMemberFindUniqueArgs>(args: SelectSubset<T, UserNewMemberFindUniqueArgs<ExtArgs>>): Prisma__UserNewMemberClient<$Result.GetResult<Prisma.$UserNewMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserNewMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserNewMemberFindUniqueOrThrowArgs} args - Arguments to find a UserNewMember
     * @example
     * // Get one UserNewMember
     * const userNewMember = await prisma.userNewMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserNewMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, UserNewMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserNewMemberClient<$Result.GetResult<Prisma.$UserNewMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserNewMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNewMemberFindFirstArgs} args - Arguments to find a UserNewMember
     * @example
     * // Get one UserNewMember
     * const userNewMember = await prisma.userNewMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserNewMemberFindFirstArgs>(args?: SelectSubset<T, UserNewMemberFindFirstArgs<ExtArgs>>): Prisma__UserNewMemberClient<$Result.GetResult<Prisma.$UserNewMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserNewMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNewMemberFindFirstOrThrowArgs} args - Arguments to find a UserNewMember
     * @example
     * // Get one UserNewMember
     * const userNewMember = await prisma.userNewMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserNewMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, UserNewMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserNewMemberClient<$Result.GetResult<Prisma.$UserNewMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserNewMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNewMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserNewMembers
     * const userNewMembers = await prisma.userNewMember.findMany()
     * 
     * // Get first 10 UserNewMembers
     * const userNewMembers = await prisma.userNewMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userNewMemberWithIdOnly = await prisma.userNewMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserNewMemberFindManyArgs>(args?: SelectSubset<T, UserNewMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNewMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserNewMember.
     * @param {UserNewMemberCreateArgs} args - Arguments to create a UserNewMember.
     * @example
     * // Create one UserNewMember
     * const UserNewMember = await prisma.userNewMember.create({
     *   data: {
     *     // ... data to create a UserNewMember
     *   }
     * })
     * 
     */
    create<T extends UserNewMemberCreateArgs>(args: SelectSubset<T, UserNewMemberCreateArgs<ExtArgs>>): Prisma__UserNewMemberClient<$Result.GetResult<Prisma.$UserNewMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserNewMembers.
     * @param {UserNewMemberCreateManyArgs} args - Arguments to create many UserNewMembers.
     * @example
     * // Create many UserNewMembers
     * const userNewMember = await prisma.userNewMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserNewMemberCreateManyArgs>(args?: SelectSubset<T, UserNewMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserNewMembers and returns the data saved in the database.
     * @param {UserNewMemberCreateManyAndReturnArgs} args - Arguments to create many UserNewMembers.
     * @example
     * // Create many UserNewMembers
     * const userNewMember = await prisma.userNewMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserNewMembers and only return the `id`
     * const userNewMemberWithIdOnly = await prisma.userNewMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserNewMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, UserNewMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNewMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserNewMember.
     * @param {UserNewMemberDeleteArgs} args - Arguments to delete one UserNewMember.
     * @example
     * // Delete one UserNewMember
     * const UserNewMember = await prisma.userNewMember.delete({
     *   where: {
     *     // ... filter to delete one UserNewMember
     *   }
     * })
     * 
     */
    delete<T extends UserNewMemberDeleteArgs>(args: SelectSubset<T, UserNewMemberDeleteArgs<ExtArgs>>): Prisma__UserNewMemberClient<$Result.GetResult<Prisma.$UserNewMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserNewMember.
     * @param {UserNewMemberUpdateArgs} args - Arguments to update one UserNewMember.
     * @example
     * // Update one UserNewMember
     * const userNewMember = await prisma.userNewMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserNewMemberUpdateArgs>(args: SelectSubset<T, UserNewMemberUpdateArgs<ExtArgs>>): Prisma__UserNewMemberClient<$Result.GetResult<Prisma.$UserNewMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserNewMembers.
     * @param {UserNewMemberDeleteManyArgs} args - Arguments to filter UserNewMembers to delete.
     * @example
     * // Delete a few UserNewMembers
     * const { count } = await prisma.userNewMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserNewMemberDeleteManyArgs>(args?: SelectSubset<T, UserNewMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserNewMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNewMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserNewMembers
     * const userNewMember = await prisma.userNewMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserNewMemberUpdateManyArgs>(args: SelectSubset<T, UserNewMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserNewMembers and returns the data updated in the database.
     * @param {UserNewMemberUpdateManyAndReturnArgs} args - Arguments to update many UserNewMembers.
     * @example
     * // Update many UserNewMembers
     * const userNewMember = await prisma.userNewMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserNewMembers and only return the `id`
     * const userNewMemberWithIdOnly = await prisma.userNewMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserNewMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, UserNewMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNewMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserNewMember.
     * @param {UserNewMemberUpsertArgs} args - Arguments to update or create a UserNewMember.
     * @example
     * // Update or create a UserNewMember
     * const userNewMember = await prisma.userNewMember.upsert({
     *   create: {
     *     // ... data to create a UserNewMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserNewMember we want to update
     *   }
     * })
     */
    upsert<T extends UserNewMemberUpsertArgs>(args: SelectSubset<T, UserNewMemberUpsertArgs<ExtArgs>>): Prisma__UserNewMemberClient<$Result.GetResult<Prisma.$UserNewMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserNewMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNewMemberCountArgs} args - Arguments to filter UserNewMembers to count.
     * @example
     * // Count the number of UserNewMembers
     * const count = await prisma.userNewMember.count({
     *   where: {
     *     // ... the filter for the UserNewMembers we want to count
     *   }
     * })
    **/
    count<T extends UserNewMemberCountArgs>(
      args?: Subset<T, UserNewMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserNewMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserNewMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNewMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserNewMemberAggregateArgs>(args: Subset<T, UserNewMemberAggregateArgs>): Prisma.PrismaPromise<GetUserNewMemberAggregateType<T>>

    /**
     * Group by UserNewMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNewMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserNewMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserNewMemberGroupByArgs['orderBy'] }
        : { orderBy?: UserNewMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserNewMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserNewMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserNewMember model
   */
  readonly fields: UserNewMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserNewMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserNewMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserNewMember model
   */
  interface UserNewMemberFieldRefs {
    readonly id: FieldRef<"UserNewMember", 'Int'>
    readonly name: FieldRef<"UserNewMember", 'String'>
    readonly email: FieldRef<"UserNewMember", 'String'>
    readonly subscription: FieldRef<"UserNewMember", 'String'>
    readonly status: FieldRef<"UserNewMember", 'String'>
    readonly action: FieldRef<"UserNewMember", 'String'>
    readonly userId: FieldRef<"UserNewMember", 'Int'>
    readonly createdAt: FieldRef<"UserNewMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserNewMember findUnique
   */
  export type UserNewMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNewMember
     */
    select?: UserNewMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNewMember
     */
    omit?: UserNewMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNewMemberInclude<ExtArgs> | null
    /**
     * Filter, which UserNewMember to fetch.
     */
    where: UserNewMemberWhereUniqueInput
  }

  /**
   * UserNewMember findUniqueOrThrow
   */
  export type UserNewMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNewMember
     */
    select?: UserNewMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNewMember
     */
    omit?: UserNewMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNewMemberInclude<ExtArgs> | null
    /**
     * Filter, which UserNewMember to fetch.
     */
    where: UserNewMemberWhereUniqueInput
  }

  /**
   * UserNewMember findFirst
   */
  export type UserNewMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNewMember
     */
    select?: UserNewMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNewMember
     */
    omit?: UserNewMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNewMemberInclude<ExtArgs> | null
    /**
     * Filter, which UserNewMember to fetch.
     */
    where?: UserNewMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNewMembers to fetch.
     */
    orderBy?: UserNewMemberOrderByWithRelationInput | UserNewMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNewMembers.
     */
    cursor?: UserNewMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNewMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNewMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNewMembers.
     */
    distinct?: UserNewMemberScalarFieldEnum | UserNewMemberScalarFieldEnum[]
  }

  /**
   * UserNewMember findFirstOrThrow
   */
  export type UserNewMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNewMember
     */
    select?: UserNewMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNewMember
     */
    omit?: UserNewMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNewMemberInclude<ExtArgs> | null
    /**
     * Filter, which UserNewMember to fetch.
     */
    where?: UserNewMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNewMembers to fetch.
     */
    orderBy?: UserNewMemberOrderByWithRelationInput | UserNewMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNewMembers.
     */
    cursor?: UserNewMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNewMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNewMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNewMembers.
     */
    distinct?: UserNewMemberScalarFieldEnum | UserNewMemberScalarFieldEnum[]
  }

  /**
   * UserNewMember findMany
   */
  export type UserNewMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNewMember
     */
    select?: UserNewMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNewMember
     */
    omit?: UserNewMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNewMemberInclude<ExtArgs> | null
    /**
     * Filter, which UserNewMembers to fetch.
     */
    where?: UserNewMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNewMembers to fetch.
     */
    orderBy?: UserNewMemberOrderByWithRelationInput | UserNewMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserNewMembers.
     */
    cursor?: UserNewMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNewMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNewMembers.
     */
    skip?: number
    distinct?: UserNewMemberScalarFieldEnum | UserNewMemberScalarFieldEnum[]
  }

  /**
   * UserNewMember create
   */
  export type UserNewMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNewMember
     */
    select?: UserNewMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNewMember
     */
    omit?: UserNewMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNewMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a UserNewMember.
     */
    data: XOR<UserNewMemberCreateInput, UserNewMemberUncheckedCreateInput>
  }

  /**
   * UserNewMember createMany
   */
  export type UserNewMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserNewMembers.
     */
    data: UserNewMemberCreateManyInput | UserNewMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserNewMember createManyAndReturn
   */
  export type UserNewMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNewMember
     */
    select?: UserNewMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserNewMember
     */
    omit?: UserNewMemberOmit<ExtArgs> | null
    /**
     * The data used to create many UserNewMembers.
     */
    data: UserNewMemberCreateManyInput | UserNewMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNewMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserNewMember update
   */
  export type UserNewMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNewMember
     */
    select?: UserNewMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNewMember
     */
    omit?: UserNewMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNewMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a UserNewMember.
     */
    data: XOR<UserNewMemberUpdateInput, UserNewMemberUncheckedUpdateInput>
    /**
     * Choose, which UserNewMember to update.
     */
    where: UserNewMemberWhereUniqueInput
  }

  /**
   * UserNewMember updateMany
   */
  export type UserNewMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserNewMembers.
     */
    data: XOR<UserNewMemberUpdateManyMutationInput, UserNewMemberUncheckedUpdateManyInput>
    /**
     * Filter which UserNewMembers to update
     */
    where?: UserNewMemberWhereInput
    /**
     * Limit how many UserNewMembers to update.
     */
    limit?: number
  }

  /**
   * UserNewMember updateManyAndReturn
   */
  export type UserNewMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNewMember
     */
    select?: UserNewMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserNewMember
     */
    omit?: UserNewMemberOmit<ExtArgs> | null
    /**
     * The data used to update UserNewMembers.
     */
    data: XOR<UserNewMemberUpdateManyMutationInput, UserNewMemberUncheckedUpdateManyInput>
    /**
     * Filter which UserNewMembers to update
     */
    where?: UserNewMemberWhereInput
    /**
     * Limit how many UserNewMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNewMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserNewMember upsert
   */
  export type UserNewMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNewMember
     */
    select?: UserNewMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNewMember
     */
    omit?: UserNewMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNewMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the UserNewMember to update in case it exists.
     */
    where: UserNewMemberWhereUniqueInput
    /**
     * In case the UserNewMember found by the `where` argument doesn't exist, create a new UserNewMember with this data.
     */
    create: XOR<UserNewMemberCreateInput, UserNewMemberUncheckedCreateInput>
    /**
     * In case the UserNewMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserNewMemberUpdateInput, UserNewMemberUncheckedUpdateInput>
  }

  /**
   * UserNewMember delete
   */
  export type UserNewMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNewMember
     */
    select?: UserNewMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNewMember
     */
    omit?: UserNewMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNewMemberInclude<ExtArgs> | null
    /**
     * Filter which UserNewMember to delete.
     */
    where: UserNewMemberWhereUniqueInput
  }

  /**
   * UserNewMember deleteMany
   */
  export type UserNewMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNewMembers to delete
     */
    where?: UserNewMemberWhereInput
    /**
     * Limit how many UserNewMembers to delete.
     */
    limit?: number
  }

  /**
   * UserNewMember without action
   */
  export type UserNewMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNewMember
     */
    select?: UserNewMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNewMember
     */
    omit?: UserNewMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNewMemberInclude<ExtArgs> | null
  }


  /**
   * Model Instructor
   */

  export type AggregateInstructor = {
    _count: InstructorCountAggregateOutputType | null
    _avg: InstructorAvgAggregateOutputType | null
    _sum: InstructorSumAggregateOutputType | null
    _min: InstructorMinAggregateOutputType | null
    _max: InstructorMaxAggregateOutputType | null
  }

  export type InstructorAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type InstructorSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type InstructorMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    status: string | null
    action: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstructorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    status: string | null
    action: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstructorCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    status: number
    action: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InstructorAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type InstructorSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type InstructorMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    status?: true
    action?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstructorMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    status?: true
    action?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstructorCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    status?: true
    action?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InstructorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instructor to aggregate.
     */
    where?: InstructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instructors to fetch.
     */
    orderBy?: InstructorOrderByWithRelationInput | InstructorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instructors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instructors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Instructors
    **/
    _count?: true | InstructorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstructorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstructorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstructorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstructorMaxAggregateInputType
  }

  export type GetInstructorAggregateType<T extends InstructorAggregateArgs> = {
        [P in keyof T & keyof AggregateInstructor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstructor[P]>
      : GetScalarType<T[P], AggregateInstructor[P]>
  }




  export type InstructorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstructorWhereInput
    orderBy?: InstructorOrderByWithAggregationInput | InstructorOrderByWithAggregationInput[]
    by: InstructorScalarFieldEnum[] | InstructorScalarFieldEnum
    having?: InstructorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstructorCountAggregateInputType | true
    _avg?: InstructorAvgAggregateInputType
    _sum?: InstructorSumAggregateInputType
    _min?: InstructorMinAggregateInputType
    _max?: InstructorMaxAggregateInputType
  }

  export type InstructorGroupByOutputType = {
    id: number
    name: string
    email: string
    phone: string | null
    status: string | null
    action: string | null
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: InstructorCountAggregateOutputType | null
    _avg: InstructorAvgAggregateOutputType | null
    _sum: InstructorSumAggregateOutputType | null
    _min: InstructorMinAggregateOutputType | null
    _max: InstructorMaxAggregateOutputType | null
  }

  type GetInstructorGroupByPayload<T extends InstructorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstructorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstructorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstructorGroupByOutputType[P]>
            : GetScalarType<T[P], InstructorGroupByOutputType[P]>
        }
      >
    >


  export type InstructorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    action?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    userInstructor?: boolean | Instructor$userInstructorArgs<ExtArgs>
  }, ExtArgs["result"]["instructor"]>

  export type InstructorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    action?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instructor"]>

  export type InstructorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    action?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instructor"]>

  export type InstructorSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    action?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InstructorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "status" | "action" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["instructor"]>
  export type InstructorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    userInstructor?: boolean | Instructor$userInstructorArgs<ExtArgs>
  }
  export type InstructorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InstructorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InstructorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Instructor"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      userInstructor: Prisma.$UserInstructorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      phone: string | null
      status: string | null
      action: string | null
      userId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["instructor"]>
    composites: {}
  }

  type InstructorGetPayload<S extends boolean | null | undefined | InstructorDefaultArgs> = $Result.GetResult<Prisma.$InstructorPayload, S>

  type InstructorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstructorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstructorCountAggregateInputType | true
    }

  export interface InstructorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Instructor'], meta: { name: 'Instructor' } }
    /**
     * Find zero or one Instructor that matches the filter.
     * @param {InstructorFindUniqueArgs} args - Arguments to find a Instructor
     * @example
     * // Get one Instructor
     * const instructor = await prisma.instructor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstructorFindUniqueArgs>(args: SelectSubset<T, InstructorFindUniqueArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Instructor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstructorFindUniqueOrThrowArgs} args - Arguments to find a Instructor
     * @example
     * // Get one Instructor
     * const instructor = await prisma.instructor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstructorFindUniqueOrThrowArgs>(args: SelectSubset<T, InstructorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Instructor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorFindFirstArgs} args - Arguments to find a Instructor
     * @example
     * // Get one Instructor
     * const instructor = await prisma.instructor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstructorFindFirstArgs>(args?: SelectSubset<T, InstructorFindFirstArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Instructor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorFindFirstOrThrowArgs} args - Arguments to find a Instructor
     * @example
     * // Get one Instructor
     * const instructor = await prisma.instructor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstructorFindFirstOrThrowArgs>(args?: SelectSubset<T, InstructorFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Instructors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instructors
     * const instructors = await prisma.instructor.findMany()
     * 
     * // Get first 10 Instructors
     * const instructors = await prisma.instructor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instructorWithIdOnly = await prisma.instructor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstructorFindManyArgs>(args?: SelectSubset<T, InstructorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Instructor.
     * @param {InstructorCreateArgs} args - Arguments to create a Instructor.
     * @example
     * // Create one Instructor
     * const Instructor = await prisma.instructor.create({
     *   data: {
     *     // ... data to create a Instructor
     *   }
     * })
     * 
     */
    create<T extends InstructorCreateArgs>(args: SelectSubset<T, InstructorCreateArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Instructors.
     * @param {InstructorCreateManyArgs} args - Arguments to create many Instructors.
     * @example
     * // Create many Instructors
     * const instructor = await prisma.instructor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstructorCreateManyArgs>(args?: SelectSubset<T, InstructorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Instructors and returns the data saved in the database.
     * @param {InstructorCreateManyAndReturnArgs} args - Arguments to create many Instructors.
     * @example
     * // Create many Instructors
     * const instructor = await prisma.instructor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Instructors and only return the `id`
     * const instructorWithIdOnly = await prisma.instructor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstructorCreateManyAndReturnArgs>(args?: SelectSubset<T, InstructorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Instructor.
     * @param {InstructorDeleteArgs} args - Arguments to delete one Instructor.
     * @example
     * // Delete one Instructor
     * const Instructor = await prisma.instructor.delete({
     *   where: {
     *     // ... filter to delete one Instructor
     *   }
     * })
     * 
     */
    delete<T extends InstructorDeleteArgs>(args: SelectSubset<T, InstructorDeleteArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Instructor.
     * @param {InstructorUpdateArgs} args - Arguments to update one Instructor.
     * @example
     * // Update one Instructor
     * const instructor = await prisma.instructor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstructorUpdateArgs>(args: SelectSubset<T, InstructorUpdateArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Instructors.
     * @param {InstructorDeleteManyArgs} args - Arguments to filter Instructors to delete.
     * @example
     * // Delete a few Instructors
     * const { count } = await prisma.instructor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstructorDeleteManyArgs>(args?: SelectSubset<T, InstructorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instructors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instructors
     * const instructor = await prisma.instructor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstructorUpdateManyArgs>(args: SelectSubset<T, InstructorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instructors and returns the data updated in the database.
     * @param {InstructorUpdateManyAndReturnArgs} args - Arguments to update many Instructors.
     * @example
     * // Update many Instructors
     * const instructor = await prisma.instructor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Instructors and only return the `id`
     * const instructorWithIdOnly = await prisma.instructor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstructorUpdateManyAndReturnArgs>(args: SelectSubset<T, InstructorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Instructor.
     * @param {InstructorUpsertArgs} args - Arguments to update or create a Instructor.
     * @example
     * // Update or create a Instructor
     * const instructor = await prisma.instructor.upsert({
     *   create: {
     *     // ... data to create a Instructor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instructor we want to update
     *   }
     * })
     */
    upsert<T extends InstructorUpsertArgs>(args: SelectSubset<T, InstructorUpsertArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Instructors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorCountArgs} args - Arguments to filter Instructors to count.
     * @example
     * // Count the number of Instructors
     * const count = await prisma.instructor.count({
     *   where: {
     *     // ... the filter for the Instructors we want to count
     *   }
     * })
    **/
    count<T extends InstructorCountArgs>(
      args?: Subset<T, InstructorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstructorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instructor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstructorAggregateArgs>(args: Subset<T, InstructorAggregateArgs>): Prisma.PrismaPromise<GetInstructorAggregateType<T>>

    /**
     * Group by Instructor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstructorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstructorGroupByArgs['orderBy'] }
        : { orderBy?: InstructorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstructorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstructorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Instructor model
   */
  readonly fields: InstructorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Instructor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstructorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    userInstructor<T extends Instructor$userInstructorArgs<ExtArgs> = {}>(args?: Subset<T, Instructor$userInstructorArgs<ExtArgs>>): Prisma__UserInstructorClient<$Result.GetResult<Prisma.$UserInstructorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Instructor model
   */
  interface InstructorFieldRefs {
    readonly id: FieldRef<"Instructor", 'Int'>
    readonly name: FieldRef<"Instructor", 'String'>
    readonly email: FieldRef<"Instructor", 'String'>
    readonly phone: FieldRef<"Instructor", 'String'>
    readonly status: FieldRef<"Instructor", 'String'>
    readonly action: FieldRef<"Instructor", 'String'>
    readonly userId: FieldRef<"Instructor", 'Int'>
    readonly createdAt: FieldRef<"Instructor", 'DateTime'>
    readonly updatedAt: FieldRef<"Instructor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Instructor findUnique
   */
  export type InstructorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * Filter, which Instructor to fetch.
     */
    where: InstructorWhereUniqueInput
  }

  /**
   * Instructor findUniqueOrThrow
   */
  export type InstructorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * Filter, which Instructor to fetch.
     */
    where: InstructorWhereUniqueInput
  }

  /**
   * Instructor findFirst
   */
  export type InstructorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * Filter, which Instructor to fetch.
     */
    where?: InstructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instructors to fetch.
     */
    orderBy?: InstructorOrderByWithRelationInput | InstructorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instructors.
     */
    cursor?: InstructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instructors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instructors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instructors.
     */
    distinct?: InstructorScalarFieldEnum | InstructorScalarFieldEnum[]
  }

  /**
   * Instructor findFirstOrThrow
   */
  export type InstructorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * Filter, which Instructor to fetch.
     */
    where?: InstructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instructors to fetch.
     */
    orderBy?: InstructorOrderByWithRelationInput | InstructorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instructors.
     */
    cursor?: InstructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instructors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instructors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instructors.
     */
    distinct?: InstructorScalarFieldEnum | InstructorScalarFieldEnum[]
  }

  /**
   * Instructor findMany
   */
  export type InstructorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * Filter, which Instructors to fetch.
     */
    where?: InstructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instructors to fetch.
     */
    orderBy?: InstructorOrderByWithRelationInput | InstructorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Instructors.
     */
    cursor?: InstructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instructors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instructors.
     */
    skip?: number
    distinct?: InstructorScalarFieldEnum | InstructorScalarFieldEnum[]
  }

  /**
   * Instructor create
   */
  export type InstructorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * The data needed to create a Instructor.
     */
    data: XOR<InstructorCreateInput, InstructorUncheckedCreateInput>
  }

  /**
   * Instructor createMany
   */
  export type InstructorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Instructors.
     */
    data: InstructorCreateManyInput | InstructorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Instructor createManyAndReturn
   */
  export type InstructorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * The data used to create many Instructors.
     */
    data: InstructorCreateManyInput | InstructorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Instructor update
   */
  export type InstructorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * The data needed to update a Instructor.
     */
    data: XOR<InstructorUpdateInput, InstructorUncheckedUpdateInput>
    /**
     * Choose, which Instructor to update.
     */
    where: InstructorWhereUniqueInput
  }

  /**
   * Instructor updateMany
   */
  export type InstructorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Instructors.
     */
    data: XOR<InstructorUpdateManyMutationInput, InstructorUncheckedUpdateManyInput>
    /**
     * Filter which Instructors to update
     */
    where?: InstructorWhereInput
    /**
     * Limit how many Instructors to update.
     */
    limit?: number
  }

  /**
   * Instructor updateManyAndReturn
   */
  export type InstructorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * The data used to update Instructors.
     */
    data: XOR<InstructorUpdateManyMutationInput, InstructorUncheckedUpdateManyInput>
    /**
     * Filter which Instructors to update
     */
    where?: InstructorWhereInput
    /**
     * Limit how many Instructors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Instructor upsert
   */
  export type InstructorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * The filter to search for the Instructor to update in case it exists.
     */
    where: InstructorWhereUniqueInput
    /**
     * In case the Instructor found by the `where` argument doesn't exist, create a new Instructor with this data.
     */
    create: XOR<InstructorCreateInput, InstructorUncheckedCreateInput>
    /**
     * In case the Instructor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstructorUpdateInput, InstructorUncheckedUpdateInput>
  }

  /**
   * Instructor delete
   */
  export type InstructorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * Filter which Instructor to delete.
     */
    where: InstructorWhereUniqueInput
  }

  /**
   * Instructor deleteMany
   */
  export type InstructorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instructors to delete
     */
    where?: InstructorWhereInput
    /**
     * Limit how many Instructors to delete.
     */
    limit?: number
  }

  /**
   * Instructor.userInstructor
   */
  export type Instructor$userInstructorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInstructor
     */
    select?: UserInstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInstructor
     */
    omit?: UserInstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInstructorInclude<ExtArgs> | null
    where?: UserInstructorWhereInput
  }

  /**
   * Instructor without action
   */
  export type InstructorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
  }


  /**
   * Model UserInstructor
   */

  export type AggregateUserInstructor = {
    _count: UserInstructorCountAggregateOutputType | null
    _avg: UserInstructorAvgAggregateOutputType | null
    _sum: UserInstructorSumAggregateOutputType | null
    _min: UserInstructorMinAggregateOutputType | null
    _max: UserInstructorMaxAggregateOutputType | null
  }

  export type UserInstructorAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    insturctorId: number | null
  }

  export type UserInstructorSumAggregateOutputType = {
    id: number | null
    userId: number | null
    insturctorId: number | null
  }

  export type UserInstructorMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    status: string | null
    action: string | null
    username: string | null
    userId: number | null
    insturctorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserInstructorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    status: string | null
    action: string | null
    username: string | null
    userId: number | null
    insturctorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserInstructorCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    status: number
    action: number
    username: number
    userId: number
    insturctorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserInstructorAvgAggregateInputType = {
    id?: true
    userId?: true
    insturctorId?: true
  }

  export type UserInstructorSumAggregateInputType = {
    id?: true
    userId?: true
    insturctorId?: true
  }

  export type UserInstructorMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    status?: true
    action?: true
    username?: true
    userId?: true
    insturctorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserInstructorMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    status?: true
    action?: true
    username?: true
    userId?: true
    insturctorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserInstructorCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    status?: true
    action?: true
    username?: true
    userId?: true
    insturctorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserInstructorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInstructor to aggregate.
     */
    where?: UserInstructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInstructors to fetch.
     */
    orderBy?: UserInstructorOrderByWithRelationInput | UserInstructorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserInstructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInstructors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInstructors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserInstructors
    **/
    _count?: true | UserInstructorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserInstructorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserInstructorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserInstructorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserInstructorMaxAggregateInputType
  }

  export type GetUserInstructorAggregateType<T extends UserInstructorAggregateArgs> = {
        [P in keyof T & keyof AggregateUserInstructor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserInstructor[P]>
      : GetScalarType<T[P], AggregateUserInstructor[P]>
  }




  export type UserInstructorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInstructorWhereInput
    orderBy?: UserInstructorOrderByWithAggregationInput | UserInstructorOrderByWithAggregationInput[]
    by: UserInstructorScalarFieldEnum[] | UserInstructorScalarFieldEnum
    having?: UserInstructorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserInstructorCountAggregateInputType | true
    _avg?: UserInstructorAvgAggregateInputType
    _sum?: UserInstructorSumAggregateInputType
    _min?: UserInstructorMinAggregateInputType
    _max?: UserInstructorMaxAggregateInputType
  }

  export type UserInstructorGroupByOutputType = {
    id: number
    name: string
    email: string
    phone: string | null
    status: string | null
    action: string | null
    username: string | null
    userId: number
    insturctorId: number
    createdAt: Date
    updatedAt: Date
    _count: UserInstructorCountAggregateOutputType | null
    _avg: UserInstructorAvgAggregateOutputType | null
    _sum: UserInstructorSumAggregateOutputType | null
    _min: UserInstructorMinAggregateOutputType | null
    _max: UserInstructorMaxAggregateOutputType | null
  }

  type GetUserInstructorGroupByPayload<T extends UserInstructorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserInstructorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserInstructorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserInstructorGroupByOutputType[P]>
            : GetScalarType<T[P], UserInstructorGroupByOutputType[P]>
        }
      >
    >


  export type UserInstructorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    action?: boolean
    username?: boolean
    userId?: boolean
    insturctorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    instructor?: boolean | InstructorDefaultArgs<ExtArgs>
    addLog?: boolean | UserInstructor$addLogArgs<ExtArgs>
    _count?: boolean | UserInstructorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInstructor"]>

  export type UserInstructorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    action?: boolean
    username?: boolean
    userId?: boolean
    insturctorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    instructor?: boolean | InstructorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInstructor"]>

  export type UserInstructorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    action?: boolean
    username?: boolean
    userId?: boolean
    insturctorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    instructor?: boolean | InstructorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInstructor"]>

  export type UserInstructorSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    action?: boolean
    username?: boolean
    userId?: boolean
    insturctorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInstructorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "status" | "action" | "username" | "userId" | "insturctorId" | "createdAt" | "updatedAt", ExtArgs["result"]["userInstructor"]>
  export type UserInstructorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    instructor?: boolean | InstructorDefaultArgs<ExtArgs>
    addLog?: boolean | UserInstructor$addLogArgs<ExtArgs>
    _count?: boolean | UserInstructorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserInstructorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    instructor?: boolean | InstructorDefaultArgs<ExtArgs>
  }
  export type UserInstructorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    instructor?: boolean | InstructorDefaultArgs<ExtArgs>
  }

  export type $UserInstructorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserInstructor"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      instructor: Prisma.$InstructorPayload<ExtArgs>
      addLog: Prisma.$AddLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      phone: string | null
      status: string | null
      action: string | null
      username: string | null
      userId: number
      insturctorId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userInstructor"]>
    composites: {}
  }

  type UserInstructorGetPayload<S extends boolean | null | undefined | UserInstructorDefaultArgs> = $Result.GetResult<Prisma.$UserInstructorPayload, S>

  type UserInstructorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserInstructorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserInstructorCountAggregateInputType | true
    }

  export interface UserInstructorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserInstructor'], meta: { name: 'UserInstructor' } }
    /**
     * Find zero or one UserInstructor that matches the filter.
     * @param {UserInstructorFindUniqueArgs} args - Arguments to find a UserInstructor
     * @example
     * // Get one UserInstructor
     * const userInstructor = await prisma.userInstructor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserInstructorFindUniqueArgs>(args: SelectSubset<T, UserInstructorFindUniqueArgs<ExtArgs>>): Prisma__UserInstructorClient<$Result.GetResult<Prisma.$UserInstructorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserInstructor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserInstructorFindUniqueOrThrowArgs} args - Arguments to find a UserInstructor
     * @example
     * // Get one UserInstructor
     * const userInstructor = await prisma.userInstructor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserInstructorFindUniqueOrThrowArgs>(args: SelectSubset<T, UserInstructorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserInstructorClient<$Result.GetResult<Prisma.$UserInstructorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserInstructor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInstructorFindFirstArgs} args - Arguments to find a UserInstructor
     * @example
     * // Get one UserInstructor
     * const userInstructor = await prisma.userInstructor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserInstructorFindFirstArgs>(args?: SelectSubset<T, UserInstructorFindFirstArgs<ExtArgs>>): Prisma__UserInstructorClient<$Result.GetResult<Prisma.$UserInstructorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserInstructor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInstructorFindFirstOrThrowArgs} args - Arguments to find a UserInstructor
     * @example
     * // Get one UserInstructor
     * const userInstructor = await prisma.userInstructor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserInstructorFindFirstOrThrowArgs>(args?: SelectSubset<T, UserInstructorFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserInstructorClient<$Result.GetResult<Prisma.$UserInstructorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserInstructors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInstructorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserInstructors
     * const userInstructors = await prisma.userInstructor.findMany()
     * 
     * // Get first 10 UserInstructors
     * const userInstructors = await prisma.userInstructor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userInstructorWithIdOnly = await prisma.userInstructor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserInstructorFindManyArgs>(args?: SelectSubset<T, UserInstructorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInstructorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserInstructor.
     * @param {UserInstructorCreateArgs} args - Arguments to create a UserInstructor.
     * @example
     * // Create one UserInstructor
     * const UserInstructor = await prisma.userInstructor.create({
     *   data: {
     *     // ... data to create a UserInstructor
     *   }
     * })
     * 
     */
    create<T extends UserInstructorCreateArgs>(args: SelectSubset<T, UserInstructorCreateArgs<ExtArgs>>): Prisma__UserInstructorClient<$Result.GetResult<Prisma.$UserInstructorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserInstructors.
     * @param {UserInstructorCreateManyArgs} args - Arguments to create many UserInstructors.
     * @example
     * // Create many UserInstructors
     * const userInstructor = await prisma.userInstructor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserInstructorCreateManyArgs>(args?: SelectSubset<T, UserInstructorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserInstructors and returns the data saved in the database.
     * @param {UserInstructorCreateManyAndReturnArgs} args - Arguments to create many UserInstructors.
     * @example
     * // Create many UserInstructors
     * const userInstructor = await prisma.userInstructor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserInstructors and only return the `id`
     * const userInstructorWithIdOnly = await prisma.userInstructor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserInstructorCreateManyAndReturnArgs>(args?: SelectSubset<T, UserInstructorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInstructorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserInstructor.
     * @param {UserInstructorDeleteArgs} args - Arguments to delete one UserInstructor.
     * @example
     * // Delete one UserInstructor
     * const UserInstructor = await prisma.userInstructor.delete({
     *   where: {
     *     // ... filter to delete one UserInstructor
     *   }
     * })
     * 
     */
    delete<T extends UserInstructorDeleteArgs>(args: SelectSubset<T, UserInstructorDeleteArgs<ExtArgs>>): Prisma__UserInstructorClient<$Result.GetResult<Prisma.$UserInstructorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserInstructor.
     * @param {UserInstructorUpdateArgs} args - Arguments to update one UserInstructor.
     * @example
     * // Update one UserInstructor
     * const userInstructor = await prisma.userInstructor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserInstructorUpdateArgs>(args: SelectSubset<T, UserInstructorUpdateArgs<ExtArgs>>): Prisma__UserInstructorClient<$Result.GetResult<Prisma.$UserInstructorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserInstructors.
     * @param {UserInstructorDeleteManyArgs} args - Arguments to filter UserInstructors to delete.
     * @example
     * // Delete a few UserInstructors
     * const { count } = await prisma.userInstructor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserInstructorDeleteManyArgs>(args?: SelectSubset<T, UserInstructorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInstructors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInstructorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserInstructors
     * const userInstructor = await prisma.userInstructor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserInstructorUpdateManyArgs>(args: SelectSubset<T, UserInstructorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInstructors and returns the data updated in the database.
     * @param {UserInstructorUpdateManyAndReturnArgs} args - Arguments to update many UserInstructors.
     * @example
     * // Update many UserInstructors
     * const userInstructor = await prisma.userInstructor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserInstructors and only return the `id`
     * const userInstructorWithIdOnly = await prisma.userInstructor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserInstructorUpdateManyAndReturnArgs>(args: SelectSubset<T, UserInstructorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInstructorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserInstructor.
     * @param {UserInstructorUpsertArgs} args - Arguments to update or create a UserInstructor.
     * @example
     * // Update or create a UserInstructor
     * const userInstructor = await prisma.userInstructor.upsert({
     *   create: {
     *     // ... data to create a UserInstructor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserInstructor we want to update
     *   }
     * })
     */
    upsert<T extends UserInstructorUpsertArgs>(args: SelectSubset<T, UserInstructorUpsertArgs<ExtArgs>>): Prisma__UserInstructorClient<$Result.GetResult<Prisma.$UserInstructorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserInstructors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInstructorCountArgs} args - Arguments to filter UserInstructors to count.
     * @example
     * // Count the number of UserInstructors
     * const count = await prisma.userInstructor.count({
     *   where: {
     *     // ... the filter for the UserInstructors we want to count
     *   }
     * })
    **/
    count<T extends UserInstructorCountArgs>(
      args?: Subset<T, UserInstructorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserInstructorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserInstructor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInstructorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserInstructorAggregateArgs>(args: Subset<T, UserInstructorAggregateArgs>): Prisma.PrismaPromise<GetUserInstructorAggregateType<T>>

    /**
     * Group by UserInstructor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInstructorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserInstructorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserInstructorGroupByArgs['orderBy'] }
        : { orderBy?: UserInstructorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserInstructorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserInstructorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserInstructor model
   */
  readonly fields: UserInstructorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserInstructor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserInstructorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    instructor<T extends InstructorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstructorDefaultArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    addLog<T extends UserInstructor$addLogArgs<ExtArgs> = {}>(args?: Subset<T, UserInstructor$addLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserInstructor model
   */
  interface UserInstructorFieldRefs {
    readonly id: FieldRef<"UserInstructor", 'Int'>
    readonly name: FieldRef<"UserInstructor", 'String'>
    readonly email: FieldRef<"UserInstructor", 'String'>
    readonly phone: FieldRef<"UserInstructor", 'String'>
    readonly status: FieldRef<"UserInstructor", 'String'>
    readonly action: FieldRef<"UserInstructor", 'String'>
    readonly username: FieldRef<"UserInstructor", 'String'>
    readonly userId: FieldRef<"UserInstructor", 'Int'>
    readonly insturctorId: FieldRef<"UserInstructor", 'Int'>
    readonly createdAt: FieldRef<"UserInstructor", 'DateTime'>
    readonly updatedAt: FieldRef<"UserInstructor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserInstructor findUnique
   */
  export type UserInstructorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInstructor
     */
    select?: UserInstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInstructor
     */
    omit?: UserInstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInstructorInclude<ExtArgs> | null
    /**
     * Filter, which UserInstructor to fetch.
     */
    where: UserInstructorWhereUniqueInput
  }

  /**
   * UserInstructor findUniqueOrThrow
   */
  export type UserInstructorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInstructor
     */
    select?: UserInstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInstructor
     */
    omit?: UserInstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInstructorInclude<ExtArgs> | null
    /**
     * Filter, which UserInstructor to fetch.
     */
    where: UserInstructorWhereUniqueInput
  }

  /**
   * UserInstructor findFirst
   */
  export type UserInstructorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInstructor
     */
    select?: UserInstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInstructor
     */
    omit?: UserInstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInstructorInclude<ExtArgs> | null
    /**
     * Filter, which UserInstructor to fetch.
     */
    where?: UserInstructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInstructors to fetch.
     */
    orderBy?: UserInstructorOrderByWithRelationInput | UserInstructorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInstructors.
     */
    cursor?: UserInstructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInstructors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInstructors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInstructors.
     */
    distinct?: UserInstructorScalarFieldEnum | UserInstructorScalarFieldEnum[]
  }

  /**
   * UserInstructor findFirstOrThrow
   */
  export type UserInstructorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInstructor
     */
    select?: UserInstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInstructor
     */
    omit?: UserInstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInstructorInclude<ExtArgs> | null
    /**
     * Filter, which UserInstructor to fetch.
     */
    where?: UserInstructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInstructors to fetch.
     */
    orderBy?: UserInstructorOrderByWithRelationInput | UserInstructorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInstructors.
     */
    cursor?: UserInstructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInstructors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInstructors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInstructors.
     */
    distinct?: UserInstructorScalarFieldEnum | UserInstructorScalarFieldEnum[]
  }

  /**
   * UserInstructor findMany
   */
  export type UserInstructorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInstructor
     */
    select?: UserInstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInstructor
     */
    omit?: UserInstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInstructorInclude<ExtArgs> | null
    /**
     * Filter, which UserInstructors to fetch.
     */
    where?: UserInstructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInstructors to fetch.
     */
    orderBy?: UserInstructorOrderByWithRelationInput | UserInstructorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserInstructors.
     */
    cursor?: UserInstructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInstructors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInstructors.
     */
    skip?: number
    distinct?: UserInstructorScalarFieldEnum | UserInstructorScalarFieldEnum[]
  }

  /**
   * UserInstructor create
   */
  export type UserInstructorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInstructor
     */
    select?: UserInstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInstructor
     */
    omit?: UserInstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInstructorInclude<ExtArgs> | null
    /**
     * The data needed to create a UserInstructor.
     */
    data: XOR<UserInstructorCreateInput, UserInstructorUncheckedCreateInput>
  }

  /**
   * UserInstructor createMany
   */
  export type UserInstructorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserInstructors.
     */
    data: UserInstructorCreateManyInput | UserInstructorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserInstructor createManyAndReturn
   */
  export type UserInstructorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInstructor
     */
    select?: UserInstructorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserInstructor
     */
    omit?: UserInstructorOmit<ExtArgs> | null
    /**
     * The data used to create many UserInstructors.
     */
    data: UserInstructorCreateManyInput | UserInstructorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInstructorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInstructor update
   */
  export type UserInstructorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInstructor
     */
    select?: UserInstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInstructor
     */
    omit?: UserInstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInstructorInclude<ExtArgs> | null
    /**
     * The data needed to update a UserInstructor.
     */
    data: XOR<UserInstructorUpdateInput, UserInstructorUncheckedUpdateInput>
    /**
     * Choose, which UserInstructor to update.
     */
    where: UserInstructorWhereUniqueInput
  }

  /**
   * UserInstructor updateMany
   */
  export type UserInstructorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserInstructors.
     */
    data: XOR<UserInstructorUpdateManyMutationInput, UserInstructorUncheckedUpdateManyInput>
    /**
     * Filter which UserInstructors to update
     */
    where?: UserInstructorWhereInput
    /**
     * Limit how many UserInstructors to update.
     */
    limit?: number
  }

  /**
   * UserInstructor updateManyAndReturn
   */
  export type UserInstructorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInstructor
     */
    select?: UserInstructorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserInstructor
     */
    omit?: UserInstructorOmit<ExtArgs> | null
    /**
     * The data used to update UserInstructors.
     */
    data: XOR<UserInstructorUpdateManyMutationInput, UserInstructorUncheckedUpdateManyInput>
    /**
     * Filter which UserInstructors to update
     */
    where?: UserInstructorWhereInput
    /**
     * Limit how many UserInstructors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInstructorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInstructor upsert
   */
  export type UserInstructorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInstructor
     */
    select?: UserInstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInstructor
     */
    omit?: UserInstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInstructorInclude<ExtArgs> | null
    /**
     * The filter to search for the UserInstructor to update in case it exists.
     */
    where: UserInstructorWhereUniqueInput
    /**
     * In case the UserInstructor found by the `where` argument doesn't exist, create a new UserInstructor with this data.
     */
    create: XOR<UserInstructorCreateInput, UserInstructorUncheckedCreateInput>
    /**
     * In case the UserInstructor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserInstructorUpdateInput, UserInstructorUncheckedUpdateInput>
  }

  /**
   * UserInstructor delete
   */
  export type UserInstructorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInstructor
     */
    select?: UserInstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInstructor
     */
    omit?: UserInstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInstructorInclude<ExtArgs> | null
    /**
     * Filter which UserInstructor to delete.
     */
    where: UserInstructorWhereUniqueInput
  }

  /**
   * UserInstructor deleteMany
   */
  export type UserInstructorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInstructors to delete
     */
    where?: UserInstructorWhereInput
    /**
     * Limit how many UserInstructors to delete.
     */
    limit?: number
  }

  /**
   * UserInstructor.addLog
   */
  export type UserInstructor$addLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddLog
     */
    select?: AddLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddLog
     */
    omit?: AddLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddLogInclude<ExtArgs> | null
    where?: AddLogWhereInput
    orderBy?: AddLogOrderByWithRelationInput | AddLogOrderByWithRelationInput[]
    cursor?: AddLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddLogScalarFieldEnum | AddLogScalarFieldEnum[]
  }

  /**
   * UserInstructor without action
   */
  export type UserInstructorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInstructor
     */
    select?: UserInstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInstructor
     */
    omit?: UserInstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInstructorInclude<ExtArgs> | null
  }


  /**
   * Model AddLog
   */

  export type AggregateAddLog = {
    _count: AddLogCountAggregateOutputType | null
    _avg: AddLogAvgAggregateOutputType | null
    _sum: AddLogSumAggregateOutputType | null
    _min: AddLogMinAggregateOutputType | null
    _max: AddLogMaxAggregateOutputType | null
  }

  export type AddLogAvgAggregateOutputType = {
    id: number | null
    flightTime: number | null
    takeoffs: number | null
    landings: number | null
    userId: number | null
    instructorId: number | null
  }

  export type AddLogSumAggregateOutputType = {
    id: number | null
    flightTime: number | null
    takeoffs: number | null
    landings: number | null
    userId: number | null
    instructorId: number | null
  }

  export type AddLogMinAggregateOutputType = {
    id: number | null
    date: Date | null
    from: string | null
    to: string | null
    aircrafttype: string | null
    tailNumber: string | null
    flightTime: number | null
    pictime: string | null
    dualrcv: string | null
    daytime: string | null
    nightime: string | null
    ifrtime: string | null
    crossCountry: string | null
    takeoffs: number | null
    landings: number | null
    userId: number | null
    instructorId: number | null
    action: $Enums.Action | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type AddLogMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    from: string | null
    to: string | null
    aircrafttype: string | null
    tailNumber: string | null
    flightTime: number | null
    pictime: string | null
    dualrcv: string | null
    daytime: string | null
    nightime: string | null
    ifrtime: string | null
    crossCountry: string | null
    takeoffs: number | null
    landings: number | null
    userId: number | null
    instructorId: number | null
    action: $Enums.Action | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type AddLogCountAggregateOutputType = {
    id: number
    date: number
    from: number
    to: number
    aircrafttype: number
    tailNumber: number
    flightTime: number
    pictime: number
    dualrcv: number
    daytime: number
    nightime: number
    ifrtime: number
    crossCountry: number
    takeoffs: number
    landings: number
    userId: number
    instructorId: number
    action: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type AddLogAvgAggregateInputType = {
    id?: true
    flightTime?: true
    takeoffs?: true
    landings?: true
    userId?: true
    instructorId?: true
  }

  export type AddLogSumAggregateInputType = {
    id?: true
    flightTime?: true
    takeoffs?: true
    landings?: true
    userId?: true
    instructorId?: true
  }

  export type AddLogMinAggregateInputType = {
    id?: true
    date?: true
    from?: true
    to?: true
    aircrafttype?: true
    tailNumber?: true
    flightTime?: true
    pictime?: true
    dualrcv?: true
    daytime?: true
    nightime?: true
    ifrtime?: true
    crossCountry?: true
    takeoffs?: true
    landings?: true
    userId?: true
    instructorId?: true
    action?: true
    updatedAt?: true
    createdAt?: true
  }

  export type AddLogMaxAggregateInputType = {
    id?: true
    date?: true
    from?: true
    to?: true
    aircrafttype?: true
    tailNumber?: true
    flightTime?: true
    pictime?: true
    dualrcv?: true
    daytime?: true
    nightime?: true
    ifrtime?: true
    crossCountry?: true
    takeoffs?: true
    landings?: true
    userId?: true
    instructorId?: true
    action?: true
    updatedAt?: true
    createdAt?: true
  }

  export type AddLogCountAggregateInputType = {
    id?: true
    date?: true
    from?: true
    to?: true
    aircrafttype?: true
    tailNumber?: true
    flightTime?: true
    pictime?: true
    dualrcv?: true
    daytime?: true
    nightime?: true
    ifrtime?: true
    crossCountry?: true
    takeoffs?: true
    landings?: true
    userId?: true
    instructorId?: true
    action?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type AddLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddLog to aggregate.
     */
    where?: AddLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddLogs to fetch.
     */
    orderBy?: AddLogOrderByWithRelationInput | AddLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddLogs
    **/
    _count?: true | AddLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddLogMaxAggregateInputType
  }

  export type GetAddLogAggregateType<T extends AddLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAddLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddLog[P]>
      : GetScalarType<T[P], AggregateAddLog[P]>
  }




  export type AddLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddLogWhereInput
    orderBy?: AddLogOrderByWithAggregationInput | AddLogOrderByWithAggregationInput[]
    by: AddLogScalarFieldEnum[] | AddLogScalarFieldEnum
    having?: AddLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddLogCountAggregateInputType | true
    _avg?: AddLogAvgAggregateInputType
    _sum?: AddLogSumAggregateInputType
    _min?: AddLogMinAggregateInputType
    _max?: AddLogMaxAggregateInputType
  }

  export type AddLogGroupByOutputType = {
    id: number
    date: Date
    from: string
    to: string
    aircrafttype: string
    tailNumber: string
    flightTime: number
    pictime: string | null
    dualrcv: string | null
    daytime: string
    nightime: string
    ifrtime: string
    crossCountry: string
    takeoffs: number
    landings: number
    userId: number
    instructorId: number
    action: $Enums.Action
    updatedAt: Date
    createdAt: Date
    _count: AddLogCountAggregateOutputType | null
    _avg: AddLogAvgAggregateOutputType | null
    _sum: AddLogSumAggregateOutputType | null
    _min: AddLogMinAggregateOutputType | null
    _max: AddLogMaxAggregateOutputType | null
  }

  type GetAddLogGroupByPayload<T extends AddLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddLogGroupByOutputType[P]>
            : GetScalarType<T[P], AddLogGroupByOutputType[P]>
        }
      >
    >


  export type AddLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    from?: boolean
    to?: boolean
    aircrafttype?: boolean
    tailNumber?: boolean
    flightTime?: boolean
    pictime?: boolean
    dualrcv?: boolean
    daytime?: boolean
    nightime?: boolean
    ifrtime?: boolean
    crossCountry?: boolean
    takeoffs?: boolean
    landings?: boolean
    userId?: boolean
    instructorId?: boolean
    action?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    instructor?: boolean | UserInstructorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addLog"]>

  export type AddLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    from?: boolean
    to?: boolean
    aircrafttype?: boolean
    tailNumber?: boolean
    flightTime?: boolean
    pictime?: boolean
    dualrcv?: boolean
    daytime?: boolean
    nightime?: boolean
    ifrtime?: boolean
    crossCountry?: boolean
    takeoffs?: boolean
    landings?: boolean
    userId?: boolean
    instructorId?: boolean
    action?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    instructor?: boolean | UserInstructorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addLog"]>

  export type AddLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    from?: boolean
    to?: boolean
    aircrafttype?: boolean
    tailNumber?: boolean
    flightTime?: boolean
    pictime?: boolean
    dualrcv?: boolean
    daytime?: boolean
    nightime?: boolean
    ifrtime?: boolean
    crossCountry?: boolean
    takeoffs?: boolean
    landings?: boolean
    userId?: boolean
    instructorId?: boolean
    action?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    instructor?: boolean | UserInstructorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addLog"]>

  export type AddLogSelectScalar = {
    id?: boolean
    date?: boolean
    from?: boolean
    to?: boolean
    aircrafttype?: boolean
    tailNumber?: boolean
    flightTime?: boolean
    pictime?: boolean
    dualrcv?: boolean
    daytime?: boolean
    nightime?: boolean
    ifrtime?: boolean
    crossCountry?: boolean
    takeoffs?: boolean
    landings?: boolean
    userId?: boolean
    instructorId?: boolean
    action?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type AddLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "from" | "to" | "aircrafttype" | "tailNumber" | "flightTime" | "pictime" | "dualrcv" | "daytime" | "nightime" | "ifrtime" | "crossCountry" | "takeoffs" | "landings" | "userId" | "instructorId" | "action" | "updatedAt" | "createdAt", ExtArgs["result"]["addLog"]>
  export type AddLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    instructor?: boolean | UserInstructorDefaultArgs<ExtArgs>
  }
  export type AddLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    instructor?: boolean | UserInstructorDefaultArgs<ExtArgs>
  }
  export type AddLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    instructor?: boolean | UserInstructorDefaultArgs<ExtArgs>
  }

  export type $AddLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      instructor: Prisma.$UserInstructorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      from: string
      to: string
      aircrafttype: string
      tailNumber: string
      flightTime: number
      pictime: string | null
      dualrcv: string | null
      daytime: string
      nightime: string
      ifrtime: string
      crossCountry: string
      takeoffs: number
      landings: number
      userId: number
      instructorId: number
      action: $Enums.Action
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["addLog"]>
    composites: {}
  }

  type AddLogGetPayload<S extends boolean | null | undefined | AddLogDefaultArgs> = $Result.GetResult<Prisma.$AddLogPayload, S>

  type AddLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddLogCountAggregateInputType | true
    }

  export interface AddLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddLog'], meta: { name: 'AddLog' } }
    /**
     * Find zero or one AddLog that matches the filter.
     * @param {AddLogFindUniqueArgs} args - Arguments to find a AddLog
     * @example
     * // Get one AddLog
     * const addLog = await prisma.addLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddLogFindUniqueArgs>(args: SelectSubset<T, AddLogFindUniqueArgs<ExtArgs>>): Prisma__AddLogClient<$Result.GetResult<Prisma.$AddLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AddLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddLogFindUniqueOrThrowArgs} args - Arguments to find a AddLog
     * @example
     * // Get one AddLog
     * const addLog = await prisma.addLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AddLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddLogClient<$Result.GetResult<Prisma.$AddLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddLogFindFirstArgs} args - Arguments to find a AddLog
     * @example
     * // Get one AddLog
     * const addLog = await prisma.addLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddLogFindFirstArgs>(args?: SelectSubset<T, AddLogFindFirstArgs<ExtArgs>>): Prisma__AddLogClient<$Result.GetResult<Prisma.$AddLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddLogFindFirstOrThrowArgs} args - Arguments to find a AddLog
     * @example
     * // Get one AddLog
     * const addLog = await prisma.addLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AddLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddLogClient<$Result.GetResult<Prisma.$AddLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AddLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddLogs
     * const addLogs = await prisma.addLog.findMany()
     * 
     * // Get first 10 AddLogs
     * const addLogs = await prisma.addLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addLogWithIdOnly = await prisma.addLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddLogFindManyArgs>(args?: SelectSubset<T, AddLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AddLog.
     * @param {AddLogCreateArgs} args - Arguments to create a AddLog.
     * @example
     * // Create one AddLog
     * const AddLog = await prisma.addLog.create({
     *   data: {
     *     // ... data to create a AddLog
     *   }
     * })
     * 
     */
    create<T extends AddLogCreateArgs>(args: SelectSubset<T, AddLogCreateArgs<ExtArgs>>): Prisma__AddLogClient<$Result.GetResult<Prisma.$AddLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AddLogs.
     * @param {AddLogCreateManyArgs} args - Arguments to create many AddLogs.
     * @example
     * // Create many AddLogs
     * const addLog = await prisma.addLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddLogCreateManyArgs>(args?: SelectSubset<T, AddLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AddLogs and returns the data saved in the database.
     * @param {AddLogCreateManyAndReturnArgs} args - Arguments to create many AddLogs.
     * @example
     * // Create many AddLogs
     * const addLog = await prisma.addLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AddLogs and only return the `id`
     * const addLogWithIdOnly = await prisma.addLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AddLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AddLog.
     * @param {AddLogDeleteArgs} args - Arguments to delete one AddLog.
     * @example
     * // Delete one AddLog
     * const AddLog = await prisma.addLog.delete({
     *   where: {
     *     // ... filter to delete one AddLog
     *   }
     * })
     * 
     */
    delete<T extends AddLogDeleteArgs>(args: SelectSubset<T, AddLogDeleteArgs<ExtArgs>>): Prisma__AddLogClient<$Result.GetResult<Prisma.$AddLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AddLog.
     * @param {AddLogUpdateArgs} args - Arguments to update one AddLog.
     * @example
     * // Update one AddLog
     * const addLog = await prisma.addLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddLogUpdateArgs>(args: SelectSubset<T, AddLogUpdateArgs<ExtArgs>>): Prisma__AddLogClient<$Result.GetResult<Prisma.$AddLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AddLogs.
     * @param {AddLogDeleteManyArgs} args - Arguments to filter AddLogs to delete.
     * @example
     * // Delete a few AddLogs
     * const { count } = await prisma.addLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddLogDeleteManyArgs>(args?: SelectSubset<T, AddLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddLogs
     * const addLog = await prisma.addLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddLogUpdateManyArgs>(args: SelectSubset<T, AddLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddLogs and returns the data updated in the database.
     * @param {AddLogUpdateManyAndReturnArgs} args - Arguments to update many AddLogs.
     * @example
     * // Update many AddLogs
     * const addLog = await prisma.addLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AddLogs and only return the `id`
     * const addLogWithIdOnly = await prisma.addLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AddLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AddLog.
     * @param {AddLogUpsertArgs} args - Arguments to update or create a AddLog.
     * @example
     * // Update or create a AddLog
     * const addLog = await prisma.addLog.upsert({
     *   create: {
     *     // ... data to create a AddLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddLog we want to update
     *   }
     * })
     */
    upsert<T extends AddLogUpsertArgs>(args: SelectSubset<T, AddLogUpsertArgs<ExtArgs>>): Prisma__AddLogClient<$Result.GetResult<Prisma.$AddLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AddLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddLogCountArgs} args - Arguments to filter AddLogs to count.
     * @example
     * // Count the number of AddLogs
     * const count = await prisma.addLog.count({
     *   where: {
     *     // ... the filter for the AddLogs we want to count
     *   }
     * })
    **/
    count<T extends AddLogCountArgs>(
      args?: Subset<T, AddLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddLogAggregateArgs>(args: Subset<T, AddLogAggregateArgs>): Prisma.PrismaPromise<GetAddLogAggregateType<T>>

    /**
     * Group by AddLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddLogGroupByArgs['orderBy'] }
        : { orderBy?: AddLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddLog model
   */
  readonly fields: AddLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    instructor<T extends UserInstructorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserInstructorDefaultArgs<ExtArgs>>): Prisma__UserInstructorClient<$Result.GetResult<Prisma.$UserInstructorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddLog model
   */
  interface AddLogFieldRefs {
    readonly id: FieldRef<"AddLog", 'Int'>
    readonly date: FieldRef<"AddLog", 'DateTime'>
    readonly from: FieldRef<"AddLog", 'String'>
    readonly to: FieldRef<"AddLog", 'String'>
    readonly aircrafttype: FieldRef<"AddLog", 'String'>
    readonly tailNumber: FieldRef<"AddLog", 'String'>
    readonly flightTime: FieldRef<"AddLog", 'Int'>
    readonly pictime: FieldRef<"AddLog", 'String'>
    readonly dualrcv: FieldRef<"AddLog", 'String'>
    readonly daytime: FieldRef<"AddLog", 'String'>
    readonly nightime: FieldRef<"AddLog", 'String'>
    readonly ifrtime: FieldRef<"AddLog", 'String'>
    readonly crossCountry: FieldRef<"AddLog", 'String'>
    readonly takeoffs: FieldRef<"AddLog", 'Int'>
    readonly landings: FieldRef<"AddLog", 'Int'>
    readonly userId: FieldRef<"AddLog", 'Int'>
    readonly instructorId: FieldRef<"AddLog", 'Int'>
    readonly action: FieldRef<"AddLog", 'Action'>
    readonly updatedAt: FieldRef<"AddLog", 'DateTime'>
    readonly createdAt: FieldRef<"AddLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AddLog findUnique
   */
  export type AddLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddLog
     */
    select?: AddLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddLog
     */
    omit?: AddLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddLogInclude<ExtArgs> | null
    /**
     * Filter, which AddLog to fetch.
     */
    where: AddLogWhereUniqueInput
  }

  /**
   * AddLog findUniqueOrThrow
   */
  export type AddLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddLog
     */
    select?: AddLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddLog
     */
    omit?: AddLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddLogInclude<ExtArgs> | null
    /**
     * Filter, which AddLog to fetch.
     */
    where: AddLogWhereUniqueInput
  }

  /**
   * AddLog findFirst
   */
  export type AddLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddLog
     */
    select?: AddLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddLog
     */
    omit?: AddLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddLogInclude<ExtArgs> | null
    /**
     * Filter, which AddLog to fetch.
     */
    where?: AddLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddLogs to fetch.
     */
    orderBy?: AddLogOrderByWithRelationInput | AddLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddLogs.
     */
    cursor?: AddLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddLogs.
     */
    distinct?: AddLogScalarFieldEnum | AddLogScalarFieldEnum[]
  }

  /**
   * AddLog findFirstOrThrow
   */
  export type AddLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddLog
     */
    select?: AddLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddLog
     */
    omit?: AddLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddLogInclude<ExtArgs> | null
    /**
     * Filter, which AddLog to fetch.
     */
    where?: AddLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddLogs to fetch.
     */
    orderBy?: AddLogOrderByWithRelationInput | AddLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddLogs.
     */
    cursor?: AddLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddLogs.
     */
    distinct?: AddLogScalarFieldEnum | AddLogScalarFieldEnum[]
  }

  /**
   * AddLog findMany
   */
  export type AddLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddLog
     */
    select?: AddLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddLog
     */
    omit?: AddLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddLogInclude<ExtArgs> | null
    /**
     * Filter, which AddLogs to fetch.
     */
    where?: AddLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddLogs to fetch.
     */
    orderBy?: AddLogOrderByWithRelationInput | AddLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddLogs.
     */
    cursor?: AddLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddLogs.
     */
    skip?: number
    distinct?: AddLogScalarFieldEnum | AddLogScalarFieldEnum[]
  }

  /**
   * AddLog create
   */
  export type AddLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddLog
     */
    select?: AddLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddLog
     */
    omit?: AddLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AddLog.
     */
    data: XOR<AddLogCreateInput, AddLogUncheckedCreateInput>
  }

  /**
   * AddLog createMany
   */
  export type AddLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddLogs.
     */
    data: AddLogCreateManyInput | AddLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddLog createManyAndReturn
   */
  export type AddLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddLog
     */
    select?: AddLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AddLog
     */
    omit?: AddLogOmit<ExtArgs> | null
    /**
     * The data used to create many AddLogs.
     */
    data: AddLogCreateManyInput | AddLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AddLog update
   */
  export type AddLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddLog
     */
    select?: AddLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddLog
     */
    omit?: AddLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AddLog.
     */
    data: XOR<AddLogUpdateInput, AddLogUncheckedUpdateInput>
    /**
     * Choose, which AddLog to update.
     */
    where: AddLogWhereUniqueInput
  }

  /**
   * AddLog updateMany
   */
  export type AddLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddLogs.
     */
    data: XOR<AddLogUpdateManyMutationInput, AddLogUncheckedUpdateManyInput>
    /**
     * Filter which AddLogs to update
     */
    where?: AddLogWhereInput
    /**
     * Limit how many AddLogs to update.
     */
    limit?: number
  }

  /**
   * AddLog updateManyAndReturn
   */
  export type AddLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddLog
     */
    select?: AddLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AddLog
     */
    omit?: AddLogOmit<ExtArgs> | null
    /**
     * The data used to update AddLogs.
     */
    data: XOR<AddLogUpdateManyMutationInput, AddLogUncheckedUpdateManyInput>
    /**
     * Filter which AddLogs to update
     */
    where?: AddLogWhereInput
    /**
     * Limit how many AddLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AddLog upsert
   */
  export type AddLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddLog
     */
    select?: AddLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddLog
     */
    omit?: AddLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AddLog to update in case it exists.
     */
    where: AddLogWhereUniqueInput
    /**
     * In case the AddLog found by the `where` argument doesn't exist, create a new AddLog with this data.
     */
    create: XOR<AddLogCreateInput, AddLogUncheckedCreateInput>
    /**
     * In case the AddLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddLogUpdateInput, AddLogUncheckedUpdateInput>
  }

  /**
   * AddLog delete
   */
  export type AddLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddLog
     */
    select?: AddLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddLog
     */
    omit?: AddLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddLogInclude<ExtArgs> | null
    /**
     * Filter which AddLog to delete.
     */
    where: AddLogWhereUniqueInput
  }

  /**
   * AddLog deleteMany
   */
  export type AddLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddLogs to delete
     */
    where?: AddLogWhereInput
    /**
     * Limit how many AddLogs to delete.
     */
    limit?: number
  }

  /**
   * AddLog without action
   */
  export type AddLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddLog
     */
    select?: AddLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddLog
     */
    omit?: AddLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddLogInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type LocationMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    name: string
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weather?: boolean | Location$weatherArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weather?: boolean | Location$weatherArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      weather: Prisma.$PilotWeatherPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    weather<T extends Location$weatherArgs<ExtArgs> = {}>(args?: Subset<T, Location$weatherArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PilotWeatherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.weather
   */
  export type Location$weatherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PilotWeather
     */
    select?: PilotWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PilotWeather
     */
    omit?: PilotWeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PilotWeatherInclude<ExtArgs> | null
    where?: PilotWeatherWhereInput
    orderBy?: PilotWeatherOrderByWithRelationInput | PilotWeatherOrderByWithRelationInput[]
    cursor?: PilotWeatherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PilotWeatherScalarFieldEnum | PilotWeatherScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model PilotWeather
   */

  export type AggregatePilotWeather = {
    _count: PilotWeatherCountAggregateOutputType | null
    _avg: PilotWeatherAvgAggregateOutputType | null
    _sum: PilotWeatherSumAggregateOutputType | null
    _min: PilotWeatherMinAggregateOutputType | null
    _max: PilotWeatherMaxAggregateOutputType | null
  }

  export type PilotWeatherAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PilotWeatherSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PilotWeatherMinAggregateOutputType = {
    id: number | null
    userId: number | null
    locationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PilotWeatherMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    locationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PilotWeatherCountAggregateOutputType = {
    id: number
    userId: number
    locationId: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PilotWeatherAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PilotWeatherSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PilotWeatherMinAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PilotWeatherMaxAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PilotWeatherCountAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PilotWeatherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PilotWeather to aggregate.
     */
    where?: PilotWeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PilotWeathers to fetch.
     */
    orderBy?: PilotWeatherOrderByWithRelationInput | PilotWeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PilotWeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PilotWeathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PilotWeathers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PilotWeathers
    **/
    _count?: true | PilotWeatherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PilotWeatherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PilotWeatherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PilotWeatherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PilotWeatherMaxAggregateInputType
  }

  export type GetPilotWeatherAggregateType<T extends PilotWeatherAggregateArgs> = {
        [P in keyof T & keyof AggregatePilotWeather]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePilotWeather[P]>
      : GetScalarType<T[P], AggregatePilotWeather[P]>
  }




  export type PilotWeatherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PilotWeatherWhereInput
    orderBy?: PilotWeatherOrderByWithAggregationInput | PilotWeatherOrderByWithAggregationInput[]
    by: PilotWeatherScalarFieldEnum[] | PilotWeatherScalarFieldEnum
    having?: PilotWeatherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PilotWeatherCountAggregateInputType | true
    _avg?: PilotWeatherAvgAggregateInputType
    _sum?: PilotWeatherSumAggregateInputType
    _min?: PilotWeatherMinAggregateInputType
    _max?: PilotWeatherMaxAggregateInputType
  }

  export type PilotWeatherGroupByOutputType = {
    id: number
    userId: number
    locationId: string
    data: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: PilotWeatherCountAggregateOutputType | null
    _avg: PilotWeatherAvgAggregateOutputType | null
    _sum: PilotWeatherSumAggregateOutputType | null
    _min: PilotWeatherMinAggregateOutputType | null
    _max: PilotWeatherMaxAggregateOutputType | null
  }

  type GetPilotWeatherGroupByPayload<T extends PilotWeatherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PilotWeatherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PilotWeatherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PilotWeatherGroupByOutputType[P]>
            : GetScalarType<T[P], PilotWeatherGroupByOutputType[P]>
        }
      >
    >


  export type PilotWeatherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locationId?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pilotWeather"]>

  export type PilotWeatherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locationId?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pilotWeather"]>

  export type PilotWeatherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locationId?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pilotWeather"]>

  export type PilotWeatherSelectScalar = {
    id?: boolean
    userId?: boolean
    locationId?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PilotWeatherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "locationId" | "data" | "createdAt" | "updatedAt", ExtArgs["result"]["pilotWeather"]>
  export type PilotWeatherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type PilotWeatherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type PilotWeatherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $PilotWeatherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PilotWeather"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      locationId: string
      data: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pilotWeather"]>
    composites: {}
  }

  type PilotWeatherGetPayload<S extends boolean | null | undefined | PilotWeatherDefaultArgs> = $Result.GetResult<Prisma.$PilotWeatherPayload, S>

  type PilotWeatherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PilotWeatherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PilotWeatherCountAggregateInputType | true
    }

  export interface PilotWeatherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PilotWeather'], meta: { name: 'PilotWeather' } }
    /**
     * Find zero or one PilotWeather that matches the filter.
     * @param {PilotWeatherFindUniqueArgs} args - Arguments to find a PilotWeather
     * @example
     * // Get one PilotWeather
     * const pilotWeather = await prisma.pilotWeather.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PilotWeatherFindUniqueArgs>(args: SelectSubset<T, PilotWeatherFindUniqueArgs<ExtArgs>>): Prisma__PilotWeatherClient<$Result.GetResult<Prisma.$PilotWeatherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PilotWeather that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PilotWeatherFindUniqueOrThrowArgs} args - Arguments to find a PilotWeather
     * @example
     * // Get one PilotWeather
     * const pilotWeather = await prisma.pilotWeather.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PilotWeatherFindUniqueOrThrowArgs>(args: SelectSubset<T, PilotWeatherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PilotWeatherClient<$Result.GetResult<Prisma.$PilotWeatherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PilotWeather that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PilotWeatherFindFirstArgs} args - Arguments to find a PilotWeather
     * @example
     * // Get one PilotWeather
     * const pilotWeather = await prisma.pilotWeather.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PilotWeatherFindFirstArgs>(args?: SelectSubset<T, PilotWeatherFindFirstArgs<ExtArgs>>): Prisma__PilotWeatherClient<$Result.GetResult<Prisma.$PilotWeatherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PilotWeather that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PilotWeatherFindFirstOrThrowArgs} args - Arguments to find a PilotWeather
     * @example
     * // Get one PilotWeather
     * const pilotWeather = await prisma.pilotWeather.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PilotWeatherFindFirstOrThrowArgs>(args?: SelectSubset<T, PilotWeatherFindFirstOrThrowArgs<ExtArgs>>): Prisma__PilotWeatherClient<$Result.GetResult<Prisma.$PilotWeatherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PilotWeathers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PilotWeatherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PilotWeathers
     * const pilotWeathers = await prisma.pilotWeather.findMany()
     * 
     * // Get first 10 PilotWeathers
     * const pilotWeathers = await prisma.pilotWeather.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pilotWeatherWithIdOnly = await prisma.pilotWeather.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PilotWeatherFindManyArgs>(args?: SelectSubset<T, PilotWeatherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PilotWeatherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PilotWeather.
     * @param {PilotWeatherCreateArgs} args - Arguments to create a PilotWeather.
     * @example
     * // Create one PilotWeather
     * const PilotWeather = await prisma.pilotWeather.create({
     *   data: {
     *     // ... data to create a PilotWeather
     *   }
     * })
     * 
     */
    create<T extends PilotWeatherCreateArgs>(args: SelectSubset<T, PilotWeatherCreateArgs<ExtArgs>>): Prisma__PilotWeatherClient<$Result.GetResult<Prisma.$PilotWeatherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PilotWeathers.
     * @param {PilotWeatherCreateManyArgs} args - Arguments to create many PilotWeathers.
     * @example
     * // Create many PilotWeathers
     * const pilotWeather = await prisma.pilotWeather.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PilotWeatherCreateManyArgs>(args?: SelectSubset<T, PilotWeatherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PilotWeathers and returns the data saved in the database.
     * @param {PilotWeatherCreateManyAndReturnArgs} args - Arguments to create many PilotWeathers.
     * @example
     * // Create many PilotWeathers
     * const pilotWeather = await prisma.pilotWeather.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PilotWeathers and only return the `id`
     * const pilotWeatherWithIdOnly = await prisma.pilotWeather.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PilotWeatherCreateManyAndReturnArgs>(args?: SelectSubset<T, PilotWeatherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PilotWeatherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PilotWeather.
     * @param {PilotWeatherDeleteArgs} args - Arguments to delete one PilotWeather.
     * @example
     * // Delete one PilotWeather
     * const PilotWeather = await prisma.pilotWeather.delete({
     *   where: {
     *     // ... filter to delete one PilotWeather
     *   }
     * })
     * 
     */
    delete<T extends PilotWeatherDeleteArgs>(args: SelectSubset<T, PilotWeatherDeleteArgs<ExtArgs>>): Prisma__PilotWeatherClient<$Result.GetResult<Prisma.$PilotWeatherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PilotWeather.
     * @param {PilotWeatherUpdateArgs} args - Arguments to update one PilotWeather.
     * @example
     * // Update one PilotWeather
     * const pilotWeather = await prisma.pilotWeather.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PilotWeatherUpdateArgs>(args: SelectSubset<T, PilotWeatherUpdateArgs<ExtArgs>>): Prisma__PilotWeatherClient<$Result.GetResult<Prisma.$PilotWeatherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PilotWeathers.
     * @param {PilotWeatherDeleteManyArgs} args - Arguments to filter PilotWeathers to delete.
     * @example
     * // Delete a few PilotWeathers
     * const { count } = await prisma.pilotWeather.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PilotWeatherDeleteManyArgs>(args?: SelectSubset<T, PilotWeatherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PilotWeathers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PilotWeatherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PilotWeathers
     * const pilotWeather = await prisma.pilotWeather.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PilotWeatherUpdateManyArgs>(args: SelectSubset<T, PilotWeatherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PilotWeathers and returns the data updated in the database.
     * @param {PilotWeatherUpdateManyAndReturnArgs} args - Arguments to update many PilotWeathers.
     * @example
     * // Update many PilotWeathers
     * const pilotWeather = await prisma.pilotWeather.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PilotWeathers and only return the `id`
     * const pilotWeatherWithIdOnly = await prisma.pilotWeather.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PilotWeatherUpdateManyAndReturnArgs>(args: SelectSubset<T, PilotWeatherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PilotWeatherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PilotWeather.
     * @param {PilotWeatherUpsertArgs} args - Arguments to update or create a PilotWeather.
     * @example
     * // Update or create a PilotWeather
     * const pilotWeather = await prisma.pilotWeather.upsert({
     *   create: {
     *     // ... data to create a PilotWeather
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PilotWeather we want to update
     *   }
     * })
     */
    upsert<T extends PilotWeatherUpsertArgs>(args: SelectSubset<T, PilotWeatherUpsertArgs<ExtArgs>>): Prisma__PilotWeatherClient<$Result.GetResult<Prisma.$PilotWeatherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PilotWeathers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PilotWeatherCountArgs} args - Arguments to filter PilotWeathers to count.
     * @example
     * // Count the number of PilotWeathers
     * const count = await prisma.pilotWeather.count({
     *   where: {
     *     // ... the filter for the PilotWeathers we want to count
     *   }
     * })
    **/
    count<T extends PilotWeatherCountArgs>(
      args?: Subset<T, PilotWeatherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PilotWeatherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PilotWeather.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PilotWeatherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PilotWeatherAggregateArgs>(args: Subset<T, PilotWeatherAggregateArgs>): Prisma.PrismaPromise<GetPilotWeatherAggregateType<T>>

    /**
     * Group by PilotWeather.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PilotWeatherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PilotWeatherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PilotWeatherGroupByArgs['orderBy'] }
        : { orderBy?: PilotWeatherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PilotWeatherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPilotWeatherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PilotWeather model
   */
  readonly fields: PilotWeatherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PilotWeather.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PilotWeatherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PilotWeather model
   */
  interface PilotWeatherFieldRefs {
    readonly id: FieldRef<"PilotWeather", 'Int'>
    readonly userId: FieldRef<"PilotWeather", 'Int'>
    readonly locationId: FieldRef<"PilotWeather", 'String'>
    readonly data: FieldRef<"PilotWeather", 'Json'>
    readonly createdAt: FieldRef<"PilotWeather", 'DateTime'>
    readonly updatedAt: FieldRef<"PilotWeather", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PilotWeather findUnique
   */
  export type PilotWeatherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PilotWeather
     */
    select?: PilotWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PilotWeather
     */
    omit?: PilotWeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PilotWeatherInclude<ExtArgs> | null
    /**
     * Filter, which PilotWeather to fetch.
     */
    where: PilotWeatherWhereUniqueInput
  }

  /**
   * PilotWeather findUniqueOrThrow
   */
  export type PilotWeatherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PilotWeather
     */
    select?: PilotWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PilotWeather
     */
    omit?: PilotWeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PilotWeatherInclude<ExtArgs> | null
    /**
     * Filter, which PilotWeather to fetch.
     */
    where: PilotWeatherWhereUniqueInput
  }

  /**
   * PilotWeather findFirst
   */
  export type PilotWeatherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PilotWeather
     */
    select?: PilotWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PilotWeather
     */
    omit?: PilotWeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PilotWeatherInclude<ExtArgs> | null
    /**
     * Filter, which PilotWeather to fetch.
     */
    where?: PilotWeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PilotWeathers to fetch.
     */
    orderBy?: PilotWeatherOrderByWithRelationInput | PilotWeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PilotWeathers.
     */
    cursor?: PilotWeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PilotWeathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PilotWeathers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PilotWeathers.
     */
    distinct?: PilotWeatherScalarFieldEnum | PilotWeatherScalarFieldEnum[]
  }

  /**
   * PilotWeather findFirstOrThrow
   */
  export type PilotWeatherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PilotWeather
     */
    select?: PilotWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PilotWeather
     */
    omit?: PilotWeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PilotWeatherInclude<ExtArgs> | null
    /**
     * Filter, which PilotWeather to fetch.
     */
    where?: PilotWeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PilotWeathers to fetch.
     */
    orderBy?: PilotWeatherOrderByWithRelationInput | PilotWeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PilotWeathers.
     */
    cursor?: PilotWeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PilotWeathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PilotWeathers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PilotWeathers.
     */
    distinct?: PilotWeatherScalarFieldEnum | PilotWeatherScalarFieldEnum[]
  }

  /**
   * PilotWeather findMany
   */
  export type PilotWeatherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PilotWeather
     */
    select?: PilotWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PilotWeather
     */
    omit?: PilotWeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PilotWeatherInclude<ExtArgs> | null
    /**
     * Filter, which PilotWeathers to fetch.
     */
    where?: PilotWeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PilotWeathers to fetch.
     */
    orderBy?: PilotWeatherOrderByWithRelationInput | PilotWeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PilotWeathers.
     */
    cursor?: PilotWeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PilotWeathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PilotWeathers.
     */
    skip?: number
    distinct?: PilotWeatherScalarFieldEnum | PilotWeatherScalarFieldEnum[]
  }

  /**
   * PilotWeather create
   */
  export type PilotWeatherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PilotWeather
     */
    select?: PilotWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PilotWeather
     */
    omit?: PilotWeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PilotWeatherInclude<ExtArgs> | null
    /**
     * The data needed to create a PilotWeather.
     */
    data: XOR<PilotWeatherCreateInput, PilotWeatherUncheckedCreateInput>
  }

  /**
   * PilotWeather createMany
   */
  export type PilotWeatherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PilotWeathers.
     */
    data: PilotWeatherCreateManyInput | PilotWeatherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PilotWeather createManyAndReturn
   */
  export type PilotWeatherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PilotWeather
     */
    select?: PilotWeatherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PilotWeather
     */
    omit?: PilotWeatherOmit<ExtArgs> | null
    /**
     * The data used to create many PilotWeathers.
     */
    data: PilotWeatherCreateManyInput | PilotWeatherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PilotWeatherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PilotWeather update
   */
  export type PilotWeatherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PilotWeather
     */
    select?: PilotWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PilotWeather
     */
    omit?: PilotWeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PilotWeatherInclude<ExtArgs> | null
    /**
     * The data needed to update a PilotWeather.
     */
    data: XOR<PilotWeatherUpdateInput, PilotWeatherUncheckedUpdateInput>
    /**
     * Choose, which PilotWeather to update.
     */
    where: PilotWeatherWhereUniqueInput
  }

  /**
   * PilotWeather updateMany
   */
  export type PilotWeatherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PilotWeathers.
     */
    data: XOR<PilotWeatherUpdateManyMutationInput, PilotWeatherUncheckedUpdateManyInput>
    /**
     * Filter which PilotWeathers to update
     */
    where?: PilotWeatherWhereInput
    /**
     * Limit how many PilotWeathers to update.
     */
    limit?: number
  }

  /**
   * PilotWeather updateManyAndReturn
   */
  export type PilotWeatherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PilotWeather
     */
    select?: PilotWeatherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PilotWeather
     */
    omit?: PilotWeatherOmit<ExtArgs> | null
    /**
     * The data used to update PilotWeathers.
     */
    data: XOR<PilotWeatherUpdateManyMutationInput, PilotWeatherUncheckedUpdateManyInput>
    /**
     * Filter which PilotWeathers to update
     */
    where?: PilotWeatherWhereInput
    /**
     * Limit how many PilotWeathers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PilotWeatherIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PilotWeather upsert
   */
  export type PilotWeatherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PilotWeather
     */
    select?: PilotWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PilotWeather
     */
    omit?: PilotWeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PilotWeatherInclude<ExtArgs> | null
    /**
     * The filter to search for the PilotWeather to update in case it exists.
     */
    where: PilotWeatherWhereUniqueInput
    /**
     * In case the PilotWeather found by the `where` argument doesn't exist, create a new PilotWeather with this data.
     */
    create: XOR<PilotWeatherCreateInput, PilotWeatherUncheckedCreateInput>
    /**
     * In case the PilotWeather was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PilotWeatherUpdateInput, PilotWeatherUncheckedUpdateInput>
  }

  /**
   * PilotWeather delete
   */
  export type PilotWeatherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PilotWeather
     */
    select?: PilotWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PilotWeather
     */
    omit?: PilotWeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PilotWeatherInclude<ExtArgs> | null
    /**
     * Filter which PilotWeather to delete.
     */
    where: PilotWeatherWhereUniqueInput
  }

  /**
   * PilotWeather deleteMany
   */
  export type PilotWeatherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PilotWeathers to delete
     */
    where?: PilotWeatherWhereInput
    /**
     * Limit how many PilotWeathers to delete.
     */
    limit?: number
  }

  /**
   * PilotWeather without action
   */
  export type PilotWeatherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PilotWeather
     */
    select?: PilotWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PilotWeather
     */
    omit?: PilotWeatherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PilotWeatherInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    image: 'image',
    license: 'license',
    role: 'role',
    authProvider: 'authProvider',
    isVerified: 'isVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UcodeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    image: 'image',
    license: 'license',
    otp: 'otp',
    expiration: 'expiration',
    createdAt: 'createdAt'
  };

  export type UcodeScalarFieldEnum = (typeof UcodeScalarFieldEnum)[keyof typeof UcodeScalarFieldEnum]


  export const UserNewMemberScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    subscription: 'subscription',
    status: 'status',
    action: 'action',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type UserNewMemberScalarFieldEnum = (typeof UserNewMemberScalarFieldEnum)[keyof typeof UserNewMemberScalarFieldEnum]


  export const InstructorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    status: 'status',
    action: 'action',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InstructorScalarFieldEnum = (typeof InstructorScalarFieldEnum)[keyof typeof InstructorScalarFieldEnum]


  export const UserInstructorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    status: 'status',
    action: 'action',
    username: 'username',
    userId: 'userId',
    insturctorId: 'insturctorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserInstructorScalarFieldEnum = (typeof UserInstructorScalarFieldEnum)[keyof typeof UserInstructorScalarFieldEnum]


  export const AddLogScalarFieldEnum: {
    id: 'id',
    date: 'date',
    from: 'from',
    to: 'to',
    aircrafttype: 'aircrafttype',
    tailNumber: 'tailNumber',
    flightTime: 'flightTime',
    pictime: 'pictime',
    dualrcv: 'dualrcv',
    daytime: 'daytime',
    nightime: 'nightime',
    ifrtime: 'ifrtime',
    crossCountry: 'crossCountry',
    takeoffs: 'takeoffs',
    landings: 'landings',
    userId: 'userId',
    instructorId: 'instructorId',
    action: 'action',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type AddLogScalarFieldEnum = (typeof AddLogScalarFieldEnum)[keyof typeof AddLogScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const PilotWeatherScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    locationId: 'locationId',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PilotWeatherScalarFieldEnum = (typeof PilotWeatherScalarFieldEnum)[keyof typeof PilotWeatherScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Licese'
   */
  export type EnumLiceseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Licese'>
    


  /**
   * Reference to a field of type 'Licese[]'
   */
  export type ListEnumLiceseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Licese[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Action'
   */
  export type EnumActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Action'>
    


  /**
   * Reference to a field of type 'Action[]'
   */
  export type ListEnumActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Action[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    license?: EnumLiceseFilter<"User"> | $Enums.Licese
    role?: EnumRoleFilter<"User"> | $Enums.Role
    authProvider?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    instructor?: InstructorListRelationFilter
    addLog?: XOR<AddLogNullableScalarRelationFilter, AddLogWhereInput> | null
    userNewMember?: XOR<UserNewMemberNullableScalarRelationFilter, UserNewMemberWhereInput> | null
    pilotWeather?: XOR<PilotWeatherNullableScalarRelationFilter, PilotWeatherWhereInput> | null
    userInstructor?: XOR<UserInstructorNullableScalarRelationFilter, UserInstructorWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    license?: SortOrder
    role?: SortOrder
    authProvider?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instructor?: InstructorOrderByRelationAggregateInput
    addLog?: AddLogOrderByWithRelationInput
    userNewMember?: UserNewMemberOrderByWithRelationInput
    pilotWeather?: PilotWeatherOrderByWithRelationInput
    userInstructor?: UserInstructorOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    license?: EnumLiceseFilter<"User"> | $Enums.Licese
    role?: EnumRoleFilter<"User"> | $Enums.Role
    authProvider?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    instructor?: InstructorListRelationFilter
    addLog?: XOR<AddLogNullableScalarRelationFilter, AddLogWhereInput> | null
    userNewMember?: XOR<UserNewMemberNullableScalarRelationFilter, UserNewMemberWhereInput> | null
    pilotWeather?: XOR<PilotWeatherNullableScalarRelationFilter, PilotWeatherWhereInput> | null
    userInstructor?: XOR<UserInstructorNullableScalarRelationFilter, UserInstructorWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    license?: SortOrder
    role?: SortOrder
    authProvider?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    license?: EnumLiceseWithAggregatesFilter<"User"> | $Enums.Licese
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    authProvider?: StringNullableWithAggregatesFilter<"User"> | string | null
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UcodeWhereInput = {
    AND?: UcodeWhereInput | UcodeWhereInput[]
    OR?: UcodeWhereInput[]
    NOT?: UcodeWhereInput | UcodeWhereInput[]
    id?: IntFilter<"Ucode"> | number
    name?: StringFilter<"Ucode"> | string
    email?: StringFilter<"Ucode"> | string
    password?: StringFilter<"Ucode"> | string
    image?: StringNullableFilter<"Ucode"> | string | null
    license?: EnumLiceseFilter<"Ucode"> | $Enums.Licese
    otp?: StringNullableFilter<"Ucode"> | string | null
    expiration?: DateTimeNullableFilter<"Ucode"> | Date | string | null
    createdAt?: DateTimeFilter<"Ucode"> | Date | string
  }

  export type UcodeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    image?: SortOrderInput | SortOrder
    license?: SortOrder
    otp?: SortOrderInput | SortOrder
    expiration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type UcodeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UcodeWhereInput | UcodeWhereInput[]
    OR?: UcodeWhereInput[]
    NOT?: UcodeWhereInput | UcodeWhereInput[]
    name?: StringFilter<"Ucode"> | string
    password?: StringFilter<"Ucode"> | string
    image?: StringNullableFilter<"Ucode"> | string | null
    license?: EnumLiceseFilter<"Ucode"> | $Enums.Licese
    otp?: StringNullableFilter<"Ucode"> | string | null
    expiration?: DateTimeNullableFilter<"Ucode"> | Date | string | null
    createdAt?: DateTimeFilter<"Ucode"> | Date | string
  }, "id" | "email">

  export type UcodeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    image?: SortOrderInput | SortOrder
    license?: SortOrder
    otp?: SortOrderInput | SortOrder
    expiration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UcodeCountOrderByAggregateInput
    _avg?: UcodeAvgOrderByAggregateInput
    _max?: UcodeMaxOrderByAggregateInput
    _min?: UcodeMinOrderByAggregateInput
    _sum?: UcodeSumOrderByAggregateInput
  }

  export type UcodeScalarWhereWithAggregatesInput = {
    AND?: UcodeScalarWhereWithAggregatesInput | UcodeScalarWhereWithAggregatesInput[]
    OR?: UcodeScalarWhereWithAggregatesInput[]
    NOT?: UcodeScalarWhereWithAggregatesInput | UcodeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ucode"> | number
    name?: StringWithAggregatesFilter<"Ucode"> | string
    email?: StringWithAggregatesFilter<"Ucode"> | string
    password?: StringWithAggregatesFilter<"Ucode"> | string
    image?: StringNullableWithAggregatesFilter<"Ucode"> | string | null
    license?: EnumLiceseWithAggregatesFilter<"Ucode"> | $Enums.Licese
    otp?: StringNullableWithAggregatesFilter<"Ucode"> | string | null
    expiration?: DateTimeNullableWithAggregatesFilter<"Ucode"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Ucode"> | Date | string
  }

  export type UserNewMemberWhereInput = {
    AND?: UserNewMemberWhereInput | UserNewMemberWhereInput[]
    OR?: UserNewMemberWhereInput[]
    NOT?: UserNewMemberWhereInput | UserNewMemberWhereInput[]
    id?: IntFilter<"UserNewMember"> | number
    name?: StringFilter<"UserNewMember"> | string
    email?: StringFilter<"UserNewMember"> | string
    subscription?: StringNullableFilter<"UserNewMember"> | string | null
    status?: StringNullableFilter<"UserNewMember"> | string | null
    action?: StringNullableFilter<"UserNewMember"> | string | null
    userId?: IntFilter<"UserNewMember"> | number
    createdAt?: DateTimeFilter<"UserNewMember"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserNewMemberOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subscription?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserNewMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    userId?: number
    AND?: UserNewMemberWhereInput | UserNewMemberWhereInput[]
    OR?: UserNewMemberWhereInput[]
    NOT?: UserNewMemberWhereInput | UserNewMemberWhereInput[]
    name?: StringFilter<"UserNewMember"> | string
    subscription?: StringNullableFilter<"UserNewMember"> | string | null
    status?: StringNullableFilter<"UserNewMember"> | string | null
    action?: StringNullableFilter<"UserNewMember"> | string | null
    createdAt?: DateTimeFilter<"UserNewMember"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "email" | "userId">

  export type UserNewMemberOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subscription?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: UserNewMemberCountOrderByAggregateInput
    _avg?: UserNewMemberAvgOrderByAggregateInput
    _max?: UserNewMemberMaxOrderByAggregateInput
    _min?: UserNewMemberMinOrderByAggregateInput
    _sum?: UserNewMemberSumOrderByAggregateInput
  }

  export type UserNewMemberScalarWhereWithAggregatesInput = {
    AND?: UserNewMemberScalarWhereWithAggregatesInput | UserNewMemberScalarWhereWithAggregatesInput[]
    OR?: UserNewMemberScalarWhereWithAggregatesInput[]
    NOT?: UserNewMemberScalarWhereWithAggregatesInput | UserNewMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserNewMember"> | number
    name?: StringWithAggregatesFilter<"UserNewMember"> | string
    email?: StringWithAggregatesFilter<"UserNewMember"> | string
    subscription?: StringNullableWithAggregatesFilter<"UserNewMember"> | string | null
    status?: StringNullableWithAggregatesFilter<"UserNewMember"> | string | null
    action?: StringNullableWithAggregatesFilter<"UserNewMember"> | string | null
    userId?: IntWithAggregatesFilter<"UserNewMember"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserNewMember"> | Date | string
  }

  export type InstructorWhereInput = {
    AND?: InstructorWhereInput | InstructorWhereInput[]
    OR?: InstructorWhereInput[]
    NOT?: InstructorWhereInput | InstructorWhereInput[]
    id?: IntFilter<"Instructor"> | number
    name?: StringFilter<"Instructor"> | string
    email?: StringFilter<"Instructor"> | string
    phone?: StringNullableFilter<"Instructor"> | string | null
    status?: StringNullableFilter<"Instructor"> | string | null
    action?: StringNullableFilter<"Instructor"> | string | null
    userId?: IntFilter<"Instructor"> | number
    createdAt?: DateTimeFilter<"Instructor"> | Date | string
    updatedAt?: DateTimeFilter<"Instructor"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    userInstructor?: XOR<UserInstructorNullableScalarRelationFilter, UserInstructorWhereInput> | null
  }

  export type InstructorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    userInstructor?: UserInstructorOrderByWithRelationInput
  }

  export type InstructorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: InstructorWhereInput | InstructorWhereInput[]
    OR?: InstructorWhereInput[]
    NOT?: InstructorWhereInput | InstructorWhereInput[]
    name?: StringFilter<"Instructor"> | string
    phone?: StringNullableFilter<"Instructor"> | string | null
    status?: StringNullableFilter<"Instructor"> | string | null
    action?: StringNullableFilter<"Instructor"> | string | null
    userId?: IntFilter<"Instructor"> | number
    createdAt?: DateTimeFilter<"Instructor"> | Date | string
    updatedAt?: DateTimeFilter<"Instructor"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    userInstructor?: XOR<UserInstructorNullableScalarRelationFilter, UserInstructorWhereInput> | null
  }, "id" | "email">

  export type InstructorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InstructorCountOrderByAggregateInput
    _avg?: InstructorAvgOrderByAggregateInput
    _max?: InstructorMaxOrderByAggregateInput
    _min?: InstructorMinOrderByAggregateInput
    _sum?: InstructorSumOrderByAggregateInput
  }

  export type InstructorScalarWhereWithAggregatesInput = {
    AND?: InstructorScalarWhereWithAggregatesInput | InstructorScalarWhereWithAggregatesInput[]
    OR?: InstructorScalarWhereWithAggregatesInput[]
    NOT?: InstructorScalarWhereWithAggregatesInput | InstructorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Instructor"> | number
    name?: StringWithAggregatesFilter<"Instructor"> | string
    email?: StringWithAggregatesFilter<"Instructor"> | string
    phone?: StringNullableWithAggregatesFilter<"Instructor"> | string | null
    status?: StringNullableWithAggregatesFilter<"Instructor"> | string | null
    action?: StringNullableWithAggregatesFilter<"Instructor"> | string | null
    userId?: IntWithAggregatesFilter<"Instructor"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Instructor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Instructor"> | Date | string
  }

  export type UserInstructorWhereInput = {
    AND?: UserInstructorWhereInput | UserInstructorWhereInput[]
    OR?: UserInstructorWhereInput[]
    NOT?: UserInstructorWhereInput | UserInstructorWhereInput[]
    id?: IntFilter<"UserInstructor"> | number
    name?: StringFilter<"UserInstructor"> | string
    email?: StringFilter<"UserInstructor"> | string
    phone?: StringNullableFilter<"UserInstructor"> | string | null
    status?: StringNullableFilter<"UserInstructor"> | string | null
    action?: StringNullableFilter<"UserInstructor"> | string | null
    username?: StringNullableFilter<"UserInstructor"> | string | null
    userId?: IntFilter<"UserInstructor"> | number
    insturctorId?: IntFilter<"UserInstructor"> | number
    createdAt?: DateTimeFilter<"UserInstructor"> | Date | string
    updatedAt?: DateTimeFilter<"UserInstructor"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    instructor?: XOR<InstructorScalarRelationFilter, InstructorWhereInput>
    addLog?: AddLogListRelationFilter
  }

  export type UserInstructorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    userId?: SortOrder
    insturctorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    instructor?: InstructorOrderByWithRelationInput
    addLog?: AddLogOrderByRelationAggregateInput
  }

  export type UserInstructorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    userId?: number
    insturctorId?: number
    AND?: UserInstructorWhereInput | UserInstructorWhereInput[]
    OR?: UserInstructorWhereInput[]
    NOT?: UserInstructorWhereInput | UserInstructorWhereInput[]
    name?: StringFilter<"UserInstructor"> | string
    phone?: StringNullableFilter<"UserInstructor"> | string | null
    status?: StringNullableFilter<"UserInstructor"> | string | null
    action?: StringNullableFilter<"UserInstructor"> | string | null
    username?: StringNullableFilter<"UserInstructor"> | string | null
    createdAt?: DateTimeFilter<"UserInstructor"> | Date | string
    updatedAt?: DateTimeFilter<"UserInstructor"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    instructor?: XOR<InstructorScalarRelationFilter, InstructorWhereInput>
    addLog?: AddLogListRelationFilter
  }, "id" | "email" | "userId" | "insturctorId">

  export type UserInstructorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    userId?: SortOrder
    insturctorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserInstructorCountOrderByAggregateInput
    _avg?: UserInstructorAvgOrderByAggregateInput
    _max?: UserInstructorMaxOrderByAggregateInput
    _min?: UserInstructorMinOrderByAggregateInput
    _sum?: UserInstructorSumOrderByAggregateInput
  }

  export type UserInstructorScalarWhereWithAggregatesInput = {
    AND?: UserInstructorScalarWhereWithAggregatesInput | UserInstructorScalarWhereWithAggregatesInput[]
    OR?: UserInstructorScalarWhereWithAggregatesInput[]
    NOT?: UserInstructorScalarWhereWithAggregatesInput | UserInstructorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserInstructor"> | number
    name?: StringWithAggregatesFilter<"UserInstructor"> | string
    email?: StringWithAggregatesFilter<"UserInstructor"> | string
    phone?: StringNullableWithAggregatesFilter<"UserInstructor"> | string | null
    status?: StringNullableWithAggregatesFilter<"UserInstructor"> | string | null
    action?: StringNullableWithAggregatesFilter<"UserInstructor"> | string | null
    username?: StringNullableWithAggregatesFilter<"UserInstructor"> | string | null
    userId?: IntWithAggregatesFilter<"UserInstructor"> | number
    insturctorId?: IntWithAggregatesFilter<"UserInstructor"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserInstructor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserInstructor"> | Date | string
  }

  export type AddLogWhereInput = {
    AND?: AddLogWhereInput | AddLogWhereInput[]
    OR?: AddLogWhereInput[]
    NOT?: AddLogWhereInput | AddLogWhereInput[]
    id?: IntFilter<"AddLog"> | number
    date?: DateTimeFilter<"AddLog"> | Date | string
    from?: StringFilter<"AddLog"> | string
    to?: StringFilter<"AddLog"> | string
    aircrafttype?: StringFilter<"AddLog"> | string
    tailNumber?: StringFilter<"AddLog"> | string
    flightTime?: IntFilter<"AddLog"> | number
    pictime?: StringNullableFilter<"AddLog"> | string | null
    dualrcv?: StringNullableFilter<"AddLog"> | string | null
    daytime?: StringFilter<"AddLog"> | string
    nightime?: StringFilter<"AddLog"> | string
    ifrtime?: StringFilter<"AddLog"> | string
    crossCountry?: StringFilter<"AddLog"> | string
    takeoffs?: IntFilter<"AddLog"> | number
    landings?: IntFilter<"AddLog"> | number
    userId?: IntFilter<"AddLog"> | number
    instructorId?: IntFilter<"AddLog"> | number
    action?: EnumActionFilter<"AddLog"> | $Enums.Action
    updatedAt?: DateTimeFilter<"AddLog"> | Date | string
    createdAt?: DateTimeFilter<"AddLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    instructor?: XOR<UserInstructorScalarRelationFilter, UserInstructorWhereInput>
  }

  export type AddLogOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    from?: SortOrder
    to?: SortOrder
    aircrafttype?: SortOrder
    tailNumber?: SortOrder
    flightTime?: SortOrder
    pictime?: SortOrderInput | SortOrder
    dualrcv?: SortOrderInput | SortOrder
    daytime?: SortOrder
    nightime?: SortOrder
    ifrtime?: SortOrder
    crossCountry?: SortOrder
    takeoffs?: SortOrder
    landings?: SortOrder
    userId?: SortOrder
    instructorId?: SortOrder
    action?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    instructor?: UserInstructorOrderByWithRelationInput
  }

  export type AddLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: AddLogWhereInput | AddLogWhereInput[]
    OR?: AddLogWhereInput[]
    NOT?: AddLogWhereInput | AddLogWhereInput[]
    date?: DateTimeFilter<"AddLog"> | Date | string
    from?: StringFilter<"AddLog"> | string
    to?: StringFilter<"AddLog"> | string
    aircrafttype?: StringFilter<"AddLog"> | string
    tailNumber?: StringFilter<"AddLog"> | string
    flightTime?: IntFilter<"AddLog"> | number
    pictime?: StringNullableFilter<"AddLog"> | string | null
    dualrcv?: StringNullableFilter<"AddLog"> | string | null
    daytime?: StringFilter<"AddLog"> | string
    nightime?: StringFilter<"AddLog"> | string
    ifrtime?: StringFilter<"AddLog"> | string
    crossCountry?: StringFilter<"AddLog"> | string
    takeoffs?: IntFilter<"AddLog"> | number
    landings?: IntFilter<"AddLog"> | number
    instructorId?: IntFilter<"AddLog"> | number
    action?: EnumActionFilter<"AddLog"> | $Enums.Action
    updatedAt?: DateTimeFilter<"AddLog"> | Date | string
    createdAt?: DateTimeFilter<"AddLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    instructor?: XOR<UserInstructorScalarRelationFilter, UserInstructorWhereInput>
  }, "id" | "userId">

  export type AddLogOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    from?: SortOrder
    to?: SortOrder
    aircrafttype?: SortOrder
    tailNumber?: SortOrder
    flightTime?: SortOrder
    pictime?: SortOrderInput | SortOrder
    dualrcv?: SortOrderInput | SortOrder
    daytime?: SortOrder
    nightime?: SortOrder
    ifrtime?: SortOrder
    crossCountry?: SortOrder
    takeoffs?: SortOrder
    landings?: SortOrder
    userId?: SortOrder
    instructorId?: SortOrder
    action?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: AddLogCountOrderByAggregateInput
    _avg?: AddLogAvgOrderByAggregateInput
    _max?: AddLogMaxOrderByAggregateInput
    _min?: AddLogMinOrderByAggregateInput
    _sum?: AddLogSumOrderByAggregateInput
  }

  export type AddLogScalarWhereWithAggregatesInput = {
    AND?: AddLogScalarWhereWithAggregatesInput | AddLogScalarWhereWithAggregatesInput[]
    OR?: AddLogScalarWhereWithAggregatesInput[]
    NOT?: AddLogScalarWhereWithAggregatesInput | AddLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AddLog"> | number
    date?: DateTimeWithAggregatesFilter<"AddLog"> | Date | string
    from?: StringWithAggregatesFilter<"AddLog"> | string
    to?: StringWithAggregatesFilter<"AddLog"> | string
    aircrafttype?: StringWithAggregatesFilter<"AddLog"> | string
    tailNumber?: StringWithAggregatesFilter<"AddLog"> | string
    flightTime?: IntWithAggregatesFilter<"AddLog"> | number
    pictime?: StringNullableWithAggregatesFilter<"AddLog"> | string | null
    dualrcv?: StringNullableWithAggregatesFilter<"AddLog"> | string | null
    daytime?: StringWithAggregatesFilter<"AddLog"> | string
    nightime?: StringWithAggregatesFilter<"AddLog"> | string
    ifrtime?: StringWithAggregatesFilter<"AddLog"> | string
    crossCountry?: StringWithAggregatesFilter<"AddLog"> | string
    takeoffs?: IntWithAggregatesFilter<"AddLog"> | number
    landings?: IntWithAggregatesFilter<"AddLog"> | number
    userId?: IntWithAggregatesFilter<"AddLog"> | number
    instructorId?: IntWithAggregatesFilter<"AddLog"> | number
    action?: EnumActionWithAggregatesFilter<"AddLog"> | $Enums.Action
    updatedAt?: DateTimeWithAggregatesFilter<"AddLog"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AddLog"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    weather?: PilotWeatherListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    weather?: PilotWeatherOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    weather?: PilotWeatherListRelationFilter
  }, "id" | "name">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    name?: StringWithAggregatesFilter<"Location"> | string
  }

  export type PilotWeatherWhereInput = {
    AND?: PilotWeatherWhereInput | PilotWeatherWhereInput[]
    OR?: PilotWeatherWhereInput[]
    NOT?: PilotWeatherWhereInput | PilotWeatherWhereInput[]
    id?: IntFilter<"PilotWeather"> | number
    userId?: IntFilter<"PilotWeather"> | number
    locationId?: StringFilter<"PilotWeather"> | string
    data?: JsonFilter<"PilotWeather">
    createdAt?: DateTimeFilter<"PilotWeather"> | Date | string
    updatedAt?: DateTimeFilter<"PilotWeather"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }

  export type PilotWeatherOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
  }

  export type PilotWeatherWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    userId_locationId?: PilotWeatherUserIdLocationIdCompoundUniqueInput
    AND?: PilotWeatherWhereInput | PilotWeatherWhereInput[]
    OR?: PilotWeatherWhereInput[]
    NOT?: PilotWeatherWhereInput | PilotWeatherWhereInput[]
    locationId?: StringFilter<"PilotWeather"> | string
    data?: JsonFilter<"PilotWeather">
    createdAt?: DateTimeFilter<"PilotWeather"> | Date | string
    updatedAt?: DateTimeFilter<"PilotWeather"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }, "id" | "userId" | "userId_locationId">

  export type PilotWeatherOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PilotWeatherCountOrderByAggregateInput
    _avg?: PilotWeatherAvgOrderByAggregateInput
    _max?: PilotWeatherMaxOrderByAggregateInput
    _min?: PilotWeatherMinOrderByAggregateInput
    _sum?: PilotWeatherSumOrderByAggregateInput
  }

  export type PilotWeatherScalarWhereWithAggregatesInput = {
    AND?: PilotWeatherScalarWhereWithAggregatesInput | PilotWeatherScalarWhereWithAggregatesInput[]
    OR?: PilotWeatherScalarWhereWithAggregatesInput[]
    NOT?: PilotWeatherScalarWhereWithAggregatesInput | PilotWeatherScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PilotWeather"> | number
    userId?: IntWithAggregatesFilter<"PilotWeather"> | number
    locationId?: StringWithAggregatesFilter<"PilotWeather"> | string
    data?: JsonWithAggregatesFilter<"PilotWeather">
    createdAt?: DateTimeWithAggregatesFilter<"PilotWeather"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PilotWeather"> | Date | string
  }

  export type UserCreateInput = {
    name: string
    email: string
    password?: string | null
    image?: string | null
    license?: $Enums.Licese
    role?: $Enums.Role
    authProvider?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor?: InstructorCreateNestedManyWithoutUserInput
    addLog?: AddLogCreateNestedOneWithoutUserInput
    userNewMember?: UserNewMemberCreateNestedOneWithoutUserInput
    pilotWeather?: PilotWeatherCreateNestedOneWithoutUserInput
    userInstructor?: UserInstructorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password?: string | null
    image?: string | null
    license?: $Enums.Licese
    role?: $Enums.Role
    authProvider?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    addLog?: AddLogUncheckedCreateNestedOneWithoutUserInput
    userNewMember?: UserNewMemberUncheckedCreateNestedOneWithoutUserInput
    pilotWeather?: PilotWeatherUncheckedCreateNestedOneWithoutUserInput
    userInstructor?: UserInstructorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    license?: EnumLiceseFieldUpdateOperationsInput | $Enums.Licese
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: InstructorUpdateManyWithoutUserNestedInput
    addLog?: AddLogUpdateOneWithoutUserNestedInput
    userNewMember?: UserNewMemberUpdateOneWithoutUserNestedInput
    pilotWeather?: PilotWeatherUpdateOneWithoutUserNestedInput
    userInstructor?: UserInstructorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    license?: EnumLiceseFieldUpdateOperationsInput | $Enums.Licese
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    addLog?: AddLogUncheckedUpdateOneWithoutUserNestedInput
    userNewMember?: UserNewMemberUncheckedUpdateOneWithoutUserNestedInput
    pilotWeather?: PilotWeatherUncheckedUpdateOneWithoutUserNestedInput
    userInstructor?: UserInstructorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    email: string
    password?: string | null
    image?: string | null
    license?: $Enums.Licese
    role?: $Enums.Role
    authProvider?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    license?: EnumLiceseFieldUpdateOperationsInput | $Enums.Licese
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    license?: EnumLiceseFieldUpdateOperationsInput | $Enums.Licese
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UcodeCreateInput = {
    name: string
    email: string
    password: string
    image?: string | null
    license?: $Enums.Licese
    otp?: string | null
    expiration?: Date | string | null
    createdAt?: Date | string
  }

  export type UcodeUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password: string
    image?: string | null
    license?: $Enums.Licese
    otp?: string | null
    expiration?: Date | string | null
    createdAt?: Date | string
  }

  export type UcodeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    license?: EnumLiceseFieldUpdateOperationsInput | $Enums.Licese
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UcodeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    license?: EnumLiceseFieldUpdateOperationsInput | $Enums.Licese
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UcodeCreateManyInput = {
    id?: number
    name: string
    email: string
    password: string
    image?: string | null
    license?: $Enums.Licese
    otp?: string | null
    expiration?: Date | string | null
    createdAt?: Date | string
  }

  export type UcodeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    license?: EnumLiceseFieldUpdateOperationsInput | $Enums.Licese
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UcodeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    license?: EnumLiceseFieldUpdateOperationsInput | $Enums.Licese
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNewMemberCreateInput = {
    name: string
    email: string
    subscription?: string | null
    status?: string | null
    action?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserNewMemberInput
  }

  export type UserNewMemberUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    subscription?: string | null
    status?: string | null
    action?: string | null
    userId: number
    createdAt?: Date | string
  }

  export type UserNewMemberUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserNewMemberNestedInput
  }

  export type UserNewMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNewMemberCreateManyInput = {
    id?: number
    name: string
    email: string
    subscription?: string | null
    status?: string | null
    action?: string | null
    userId: number
    createdAt?: Date | string
  }

  export type UserNewMemberUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNewMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstructorCreateInput = {
    name: string
    email: string
    phone?: string | null
    status?: string | null
    action?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInstructorInput
    userInstructor?: UserInstructorCreateNestedOneWithoutInstructorInput
  }

  export type InstructorUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    status?: string | null
    action?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userInstructor?: UserInstructorUncheckedCreateNestedOneWithoutInstructorInput
  }

  export type InstructorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInstructorNestedInput
    userInstructor?: UserInstructorUpdateOneWithoutInstructorNestedInput
  }

  export type InstructorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userInstructor?: UserInstructorUncheckedUpdateOneWithoutInstructorNestedInput
  }

  export type InstructorCreateManyInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    status?: string | null
    action?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstructorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstructorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInstructorCreateInput = {
    name: string
    email: string
    phone?: string | null
    status?: string | null
    action?: string | null
    username?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserInstructorInput
    instructor: InstructorCreateNestedOneWithoutUserInstructorInput
    addLog?: AddLogCreateNestedManyWithoutInstructorInput
  }

  export type UserInstructorUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    status?: string | null
    action?: string | null
    username?: string | null
    userId: number
    insturctorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addLog?: AddLogUncheckedCreateNestedManyWithoutInstructorInput
  }

  export type UserInstructorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserInstructorNestedInput
    instructor?: InstructorUpdateOneRequiredWithoutUserInstructorNestedInput
    addLog?: AddLogUpdateManyWithoutInstructorNestedInput
  }

  export type UserInstructorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    insturctorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addLog?: AddLogUncheckedUpdateManyWithoutInstructorNestedInput
  }

  export type UserInstructorCreateManyInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    status?: string | null
    action?: string | null
    username?: string | null
    userId: number
    insturctorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserInstructorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInstructorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    insturctorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddLogCreateInput = {
    date?: Date | string
    from: string
    to: string
    aircrafttype: string
    tailNumber: string
    flightTime: number
    pictime?: string | null
    dualrcv?: string | null
    daytime: string
    nightime: string
    ifrtime: string
    crossCountry: string
    takeoffs: number
    landings: number
    action?: $Enums.Action
    updatedAt?: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAddLogInput
    instructor: UserInstructorCreateNestedOneWithoutAddLogInput
  }

  export type AddLogUncheckedCreateInput = {
    id?: number
    date?: Date | string
    from: string
    to: string
    aircrafttype: string
    tailNumber: string
    flightTime: number
    pictime?: string | null
    dualrcv?: string | null
    daytime: string
    nightime: string
    ifrtime: string
    crossCountry: string
    takeoffs: number
    landings: number
    userId: number
    instructorId: number
    action?: $Enums.Action
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type AddLogUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    aircrafttype?: StringFieldUpdateOperationsInput | string
    tailNumber?: StringFieldUpdateOperationsInput | string
    flightTime?: IntFieldUpdateOperationsInput | number
    pictime?: NullableStringFieldUpdateOperationsInput | string | null
    dualrcv?: NullableStringFieldUpdateOperationsInput | string | null
    daytime?: StringFieldUpdateOperationsInput | string
    nightime?: StringFieldUpdateOperationsInput | string
    ifrtime?: StringFieldUpdateOperationsInput | string
    crossCountry?: StringFieldUpdateOperationsInput | string
    takeoffs?: IntFieldUpdateOperationsInput | number
    landings?: IntFieldUpdateOperationsInput | number
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAddLogNestedInput
    instructor?: UserInstructorUpdateOneRequiredWithoutAddLogNestedInput
  }

  export type AddLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    aircrafttype?: StringFieldUpdateOperationsInput | string
    tailNumber?: StringFieldUpdateOperationsInput | string
    flightTime?: IntFieldUpdateOperationsInput | number
    pictime?: NullableStringFieldUpdateOperationsInput | string | null
    dualrcv?: NullableStringFieldUpdateOperationsInput | string | null
    daytime?: StringFieldUpdateOperationsInput | string
    nightime?: StringFieldUpdateOperationsInput | string
    ifrtime?: StringFieldUpdateOperationsInput | string
    crossCountry?: StringFieldUpdateOperationsInput | string
    takeoffs?: IntFieldUpdateOperationsInput | number
    landings?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    instructorId?: IntFieldUpdateOperationsInput | number
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddLogCreateManyInput = {
    id?: number
    date?: Date | string
    from: string
    to: string
    aircrafttype: string
    tailNumber: string
    flightTime: number
    pictime?: string | null
    dualrcv?: string | null
    daytime: string
    nightime: string
    ifrtime: string
    crossCountry: string
    takeoffs: number
    landings: number
    userId: number
    instructorId: number
    action?: $Enums.Action
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type AddLogUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    aircrafttype?: StringFieldUpdateOperationsInput | string
    tailNumber?: StringFieldUpdateOperationsInput | string
    flightTime?: IntFieldUpdateOperationsInput | number
    pictime?: NullableStringFieldUpdateOperationsInput | string | null
    dualrcv?: NullableStringFieldUpdateOperationsInput | string | null
    daytime?: StringFieldUpdateOperationsInput | string
    nightime?: StringFieldUpdateOperationsInput | string
    ifrtime?: StringFieldUpdateOperationsInput | string
    crossCountry?: StringFieldUpdateOperationsInput | string
    takeoffs?: IntFieldUpdateOperationsInput | number
    landings?: IntFieldUpdateOperationsInput | number
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    aircrafttype?: StringFieldUpdateOperationsInput | string
    tailNumber?: StringFieldUpdateOperationsInput | string
    flightTime?: IntFieldUpdateOperationsInput | number
    pictime?: NullableStringFieldUpdateOperationsInput | string | null
    dualrcv?: NullableStringFieldUpdateOperationsInput | string | null
    daytime?: StringFieldUpdateOperationsInput | string
    nightime?: StringFieldUpdateOperationsInput | string
    ifrtime?: StringFieldUpdateOperationsInput | string
    crossCountry?: StringFieldUpdateOperationsInput | string
    takeoffs?: IntFieldUpdateOperationsInput | number
    landings?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    instructorId?: IntFieldUpdateOperationsInput | number
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    id?: string
    name: string
    weather?: PilotWeatherCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    name: string
    weather?: PilotWeatherUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weather?: PilotWeatherUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weather?: PilotWeatherUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    name: string
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PilotWeatherCreateInput = {
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPilotWeatherInput
    location: LocationCreateNestedOneWithoutWeatherInput
  }

  export type PilotWeatherUncheckedCreateInput = {
    id?: number
    userId: number
    locationId: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PilotWeatherUpdateInput = {
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPilotWeatherNestedInput
    location?: LocationUpdateOneRequiredWithoutWeatherNestedInput
  }

  export type PilotWeatherUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    locationId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PilotWeatherCreateManyInput = {
    id?: number
    userId: number
    locationId: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PilotWeatherUpdateManyMutationInput = {
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PilotWeatherUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    locationId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumLiceseFilter<$PrismaModel = never> = {
    equals?: $Enums.Licese | EnumLiceseFieldRefInput<$PrismaModel>
    in?: $Enums.Licese[] | ListEnumLiceseFieldRefInput<$PrismaModel>
    notIn?: $Enums.Licese[] | ListEnumLiceseFieldRefInput<$PrismaModel>
    not?: NestedEnumLiceseFilter<$PrismaModel> | $Enums.Licese
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type InstructorListRelationFilter = {
    every?: InstructorWhereInput
    some?: InstructorWhereInput
    none?: InstructorWhereInput
  }

  export type AddLogNullableScalarRelationFilter = {
    is?: AddLogWhereInput | null
    isNot?: AddLogWhereInput | null
  }

  export type UserNewMemberNullableScalarRelationFilter = {
    is?: UserNewMemberWhereInput | null
    isNot?: UserNewMemberWhereInput | null
  }

  export type PilotWeatherNullableScalarRelationFilter = {
    is?: PilotWeatherWhereInput | null
    isNot?: PilotWeatherWhereInput | null
  }

  export type UserInstructorNullableScalarRelationFilter = {
    is?: UserInstructorWhereInput | null
    isNot?: UserInstructorWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type InstructorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    image?: SortOrder
    license?: SortOrder
    role?: SortOrder
    authProvider?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    image?: SortOrder
    license?: SortOrder
    role?: SortOrder
    authProvider?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    image?: SortOrder
    license?: SortOrder
    role?: SortOrder
    authProvider?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumLiceseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Licese | EnumLiceseFieldRefInput<$PrismaModel>
    in?: $Enums.Licese[] | ListEnumLiceseFieldRefInput<$PrismaModel>
    notIn?: $Enums.Licese[] | ListEnumLiceseFieldRefInput<$PrismaModel>
    not?: NestedEnumLiceseWithAggregatesFilter<$PrismaModel> | $Enums.Licese
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLiceseFilter<$PrismaModel>
    _max?: NestedEnumLiceseFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UcodeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    image?: SortOrder
    license?: SortOrder
    otp?: SortOrder
    expiration?: SortOrder
    createdAt?: SortOrder
  }

  export type UcodeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UcodeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    image?: SortOrder
    license?: SortOrder
    otp?: SortOrder
    expiration?: SortOrder
    createdAt?: SortOrder
  }

  export type UcodeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    image?: SortOrder
    license?: SortOrder
    otp?: SortOrder
    expiration?: SortOrder
    createdAt?: SortOrder
  }

  export type UcodeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserNewMemberCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subscription?: SortOrder
    status?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserNewMemberAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserNewMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subscription?: SortOrder
    status?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserNewMemberMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subscription?: SortOrder
    status?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserNewMemberSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type InstructorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstructorAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type InstructorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstructorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstructorSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type InstructorScalarRelationFilter = {
    is?: InstructorWhereInput
    isNot?: InstructorWhereInput
  }

  export type AddLogListRelationFilter = {
    every?: AddLogWhereInput
    some?: AddLogWhereInput
    none?: AddLogWhereInput
  }

  export type AddLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserInstructorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    action?: SortOrder
    username?: SortOrder
    userId?: SortOrder
    insturctorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserInstructorAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    insturctorId?: SortOrder
  }

  export type UserInstructorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    action?: SortOrder
    username?: SortOrder
    userId?: SortOrder
    insturctorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserInstructorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    action?: SortOrder
    username?: SortOrder
    userId?: SortOrder
    insturctorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserInstructorSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    insturctorId?: SortOrder
  }

  export type EnumActionFilter<$PrismaModel = never> = {
    equals?: $Enums.Action | EnumActionFieldRefInput<$PrismaModel>
    in?: $Enums.Action[] | ListEnumActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Action[] | ListEnumActionFieldRefInput<$PrismaModel>
    not?: NestedEnumActionFilter<$PrismaModel> | $Enums.Action
  }

  export type UserInstructorScalarRelationFilter = {
    is?: UserInstructorWhereInput
    isNot?: UserInstructorWhereInput
  }

  export type AddLogCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    from?: SortOrder
    to?: SortOrder
    aircrafttype?: SortOrder
    tailNumber?: SortOrder
    flightTime?: SortOrder
    pictime?: SortOrder
    dualrcv?: SortOrder
    daytime?: SortOrder
    nightime?: SortOrder
    ifrtime?: SortOrder
    crossCountry?: SortOrder
    takeoffs?: SortOrder
    landings?: SortOrder
    userId?: SortOrder
    instructorId?: SortOrder
    action?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AddLogAvgOrderByAggregateInput = {
    id?: SortOrder
    flightTime?: SortOrder
    takeoffs?: SortOrder
    landings?: SortOrder
    userId?: SortOrder
    instructorId?: SortOrder
  }

  export type AddLogMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    from?: SortOrder
    to?: SortOrder
    aircrafttype?: SortOrder
    tailNumber?: SortOrder
    flightTime?: SortOrder
    pictime?: SortOrder
    dualrcv?: SortOrder
    daytime?: SortOrder
    nightime?: SortOrder
    ifrtime?: SortOrder
    crossCountry?: SortOrder
    takeoffs?: SortOrder
    landings?: SortOrder
    userId?: SortOrder
    instructorId?: SortOrder
    action?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AddLogMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    from?: SortOrder
    to?: SortOrder
    aircrafttype?: SortOrder
    tailNumber?: SortOrder
    flightTime?: SortOrder
    pictime?: SortOrder
    dualrcv?: SortOrder
    daytime?: SortOrder
    nightime?: SortOrder
    ifrtime?: SortOrder
    crossCountry?: SortOrder
    takeoffs?: SortOrder
    landings?: SortOrder
    userId?: SortOrder
    instructorId?: SortOrder
    action?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AddLogSumOrderByAggregateInput = {
    id?: SortOrder
    flightTime?: SortOrder
    takeoffs?: SortOrder
    landings?: SortOrder
    userId?: SortOrder
    instructorId?: SortOrder
  }

  export type EnumActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Action | EnumActionFieldRefInput<$PrismaModel>
    in?: $Enums.Action[] | ListEnumActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Action[] | ListEnumActionFieldRefInput<$PrismaModel>
    not?: NestedEnumActionWithAggregatesFilter<$PrismaModel> | $Enums.Action
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionFilter<$PrismaModel>
    _max?: NestedEnumActionFilter<$PrismaModel>
  }

  export type PilotWeatherListRelationFilter = {
    every?: PilotWeatherWhereInput
    some?: PilotWeatherWhereInput
    none?: PilotWeatherWhereInput
  }

  export type PilotWeatherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type LocationScalarRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type PilotWeatherUserIdLocationIdCompoundUniqueInput = {
    userId: number
    locationId: string
  }

  export type PilotWeatherCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PilotWeatherAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PilotWeatherMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PilotWeatherMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PilotWeatherSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type InstructorCreateNestedManyWithoutUserInput = {
    create?: XOR<InstructorCreateWithoutUserInput, InstructorUncheckedCreateWithoutUserInput> | InstructorCreateWithoutUserInput[] | InstructorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstructorCreateOrConnectWithoutUserInput | InstructorCreateOrConnectWithoutUserInput[]
    createMany?: InstructorCreateManyUserInputEnvelope
    connect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
  }

  export type AddLogCreateNestedOneWithoutUserInput = {
    create?: XOR<AddLogCreateWithoutUserInput, AddLogUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddLogCreateOrConnectWithoutUserInput
    connect?: AddLogWhereUniqueInput
  }

  export type UserNewMemberCreateNestedOneWithoutUserInput = {
    create?: XOR<UserNewMemberCreateWithoutUserInput, UserNewMemberUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserNewMemberCreateOrConnectWithoutUserInput
    connect?: UserNewMemberWhereUniqueInput
  }

  export type PilotWeatherCreateNestedOneWithoutUserInput = {
    create?: XOR<PilotWeatherCreateWithoutUserInput, PilotWeatherUncheckedCreateWithoutUserInput>
    connectOrCreate?: PilotWeatherCreateOrConnectWithoutUserInput
    connect?: PilotWeatherWhereUniqueInput
  }

  export type UserInstructorCreateNestedOneWithoutUserInput = {
    create?: XOR<UserInstructorCreateWithoutUserInput, UserInstructorUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserInstructorCreateOrConnectWithoutUserInput
    connect?: UserInstructorWhereUniqueInput
  }

  export type InstructorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InstructorCreateWithoutUserInput, InstructorUncheckedCreateWithoutUserInput> | InstructorCreateWithoutUserInput[] | InstructorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstructorCreateOrConnectWithoutUserInput | InstructorCreateOrConnectWithoutUserInput[]
    createMany?: InstructorCreateManyUserInputEnvelope
    connect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
  }

  export type AddLogUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AddLogCreateWithoutUserInput, AddLogUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddLogCreateOrConnectWithoutUserInput
    connect?: AddLogWhereUniqueInput
  }

  export type UserNewMemberUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserNewMemberCreateWithoutUserInput, UserNewMemberUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserNewMemberCreateOrConnectWithoutUserInput
    connect?: UserNewMemberWhereUniqueInput
  }

  export type PilotWeatherUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PilotWeatherCreateWithoutUserInput, PilotWeatherUncheckedCreateWithoutUserInput>
    connectOrCreate?: PilotWeatherCreateOrConnectWithoutUserInput
    connect?: PilotWeatherWhereUniqueInput
  }

  export type UserInstructorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserInstructorCreateWithoutUserInput, UserInstructorUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserInstructorCreateOrConnectWithoutUserInput
    connect?: UserInstructorWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumLiceseFieldUpdateOperationsInput = {
    set?: $Enums.Licese
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type InstructorUpdateManyWithoutUserNestedInput = {
    create?: XOR<InstructorCreateWithoutUserInput, InstructorUncheckedCreateWithoutUserInput> | InstructorCreateWithoutUserInput[] | InstructorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstructorCreateOrConnectWithoutUserInput | InstructorCreateOrConnectWithoutUserInput[]
    upsert?: InstructorUpsertWithWhereUniqueWithoutUserInput | InstructorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InstructorCreateManyUserInputEnvelope
    set?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    disconnect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    delete?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    connect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    update?: InstructorUpdateWithWhereUniqueWithoutUserInput | InstructorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InstructorUpdateManyWithWhereWithoutUserInput | InstructorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InstructorScalarWhereInput | InstructorScalarWhereInput[]
  }

  export type AddLogUpdateOneWithoutUserNestedInput = {
    create?: XOR<AddLogCreateWithoutUserInput, AddLogUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddLogCreateOrConnectWithoutUserInput
    upsert?: AddLogUpsertWithoutUserInput
    disconnect?: AddLogWhereInput | boolean
    delete?: AddLogWhereInput | boolean
    connect?: AddLogWhereUniqueInput
    update?: XOR<XOR<AddLogUpdateToOneWithWhereWithoutUserInput, AddLogUpdateWithoutUserInput>, AddLogUncheckedUpdateWithoutUserInput>
  }

  export type UserNewMemberUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserNewMemberCreateWithoutUserInput, UserNewMemberUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserNewMemberCreateOrConnectWithoutUserInput
    upsert?: UserNewMemberUpsertWithoutUserInput
    disconnect?: UserNewMemberWhereInput | boolean
    delete?: UserNewMemberWhereInput | boolean
    connect?: UserNewMemberWhereUniqueInput
    update?: XOR<XOR<UserNewMemberUpdateToOneWithWhereWithoutUserInput, UserNewMemberUpdateWithoutUserInput>, UserNewMemberUncheckedUpdateWithoutUserInput>
  }

  export type PilotWeatherUpdateOneWithoutUserNestedInput = {
    create?: XOR<PilotWeatherCreateWithoutUserInput, PilotWeatherUncheckedCreateWithoutUserInput>
    connectOrCreate?: PilotWeatherCreateOrConnectWithoutUserInput
    upsert?: PilotWeatherUpsertWithoutUserInput
    disconnect?: PilotWeatherWhereInput | boolean
    delete?: PilotWeatherWhereInput | boolean
    connect?: PilotWeatherWhereUniqueInput
    update?: XOR<XOR<PilotWeatherUpdateToOneWithWhereWithoutUserInput, PilotWeatherUpdateWithoutUserInput>, PilotWeatherUncheckedUpdateWithoutUserInput>
  }

  export type UserInstructorUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserInstructorCreateWithoutUserInput, UserInstructorUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserInstructorCreateOrConnectWithoutUserInput
    upsert?: UserInstructorUpsertWithoutUserInput
    disconnect?: UserInstructorWhereInput | boolean
    delete?: UserInstructorWhereInput | boolean
    connect?: UserInstructorWhereUniqueInput
    update?: XOR<XOR<UserInstructorUpdateToOneWithWhereWithoutUserInput, UserInstructorUpdateWithoutUserInput>, UserInstructorUncheckedUpdateWithoutUserInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InstructorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InstructorCreateWithoutUserInput, InstructorUncheckedCreateWithoutUserInput> | InstructorCreateWithoutUserInput[] | InstructorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstructorCreateOrConnectWithoutUserInput | InstructorCreateOrConnectWithoutUserInput[]
    upsert?: InstructorUpsertWithWhereUniqueWithoutUserInput | InstructorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InstructorCreateManyUserInputEnvelope
    set?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    disconnect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    delete?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    connect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    update?: InstructorUpdateWithWhereUniqueWithoutUserInput | InstructorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InstructorUpdateManyWithWhereWithoutUserInput | InstructorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InstructorScalarWhereInput | InstructorScalarWhereInput[]
  }

  export type AddLogUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AddLogCreateWithoutUserInput, AddLogUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddLogCreateOrConnectWithoutUserInput
    upsert?: AddLogUpsertWithoutUserInput
    disconnect?: AddLogWhereInput | boolean
    delete?: AddLogWhereInput | boolean
    connect?: AddLogWhereUniqueInput
    update?: XOR<XOR<AddLogUpdateToOneWithWhereWithoutUserInput, AddLogUpdateWithoutUserInput>, AddLogUncheckedUpdateWithoutUserInput>
  }

  export type UserNewMemberUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserNewMemberCreateWithoutUserInput, UserNewMemberUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserNewMemberCreateOrConnectWithoutUserInput
    upsert?: UserNewMemberUpsertWithoutUserInput
    disconnect?: UserNewMemberWhereInput | boolean
    delete?: UserNewMemberWhereInput | boolean
    connect?: UserNewMemberWhereUniqueInput
    update?: XOR<XOR<UserNewMemberUpdateToOneWithWhereWithoutUserInput, UserNewMemberUpdateWithoutUserInput>, UserNewMemberUncheckedUpdateWithoutUserInput>
  }

  export type PilotWeatherUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PilotWeatherCreateWithoutUserInput, PilotWeatherUncheckedCreateWithoutUserInput>
    connectOrCreate?: PilotWeatherCreateOrConnectWithoutUserInput
    upsert?: PilotWeatherUpsertWithoutUserInput
    disconnect?: PilotWeatherWhereInput | boolean
    delete?: PilotWeatherWhereInput | boolean
    connect?: PilotWeatherWhereUniqueInput
    update?: XOR<XOR<PilotWeatherUpdateToOneWithWhereWithoutUserInput, PilotWeatherUpdateWithoutUserInput>, PilotWeatherUncheckedUpdateWithoutUserInput>
  }

  export type UserInstructorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserInstructorCreateWithoutUserInput, UserInstructorUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserInstructorCreateOrConnectWithoutUserInput
    upsert?: UserInstructorUpsertWithoutUserInput
    disconnect?: UserInstructorWhereInput | boolean
    delete?: UserInstructorWhereInput | boolean
    connect?: UserInstructorWhereUniqueInput
    update?: XOR<XOR<UserInstructorUpdateToOneWithWhereWithoutUserInput, UserInstructorUpdateWithoutUserInput>, UserInstructorUncheckedUpdateWithoutUserInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserCreateNestedOneWithoutUserNewMemberInput = {
    create?: XOR<UserCreateWithoutUserNewMemberInput, UserUncheckedCreateWithoutUserNewMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserNewMemberInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserNewMemberNestedInput = {
    create?: XOR<UserCreateWithoutUserNewMemberInput, UserUncheckedCreateWithoutUserNewMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserNewMemberInput
    upsert?: UserUpsertWithoutUserNewMemberInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserNewMemberInput, UserUpdateWithoutUserNewMemberInput>, UserUncheckedUpdateWithoutUserNewMemberInput>
  }

  export type UserCreateNestedOneWithoutInstructorInput = {
    create?: XOR<UserCreateWithoutInstructorInput, UserUncheckedCreateWithoutInstructorInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstructorInput
    connect?: UserWhereUniqueInput
  }

  export type UserInstructorCreateNestedOneWithoutInstructorInput = {
    create?: XOR<UserInstructorCreateWithoutInstructorInput, UserInstructorUncheckedCreateWithoutInstructorInput>
    connectOrCreate?: UserInstructorCreateOrConnectWithoutInstructorInput
    connect?: UserInstructorWhereUniqueInput
  }

  export type UserInstructorUncheckedCreateNestedOneWithoutInstructorInput = {
    create?: XOR<UserInstructorCreateWithoutInstructorInput, UserInstructorUncheckedCreateWithoutInstructorInput>
    connectOrCreate?: UserInstructorCreateOrConnectWithoutInstructorInput
    connect?: UserInstructorWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInstructorNestedInput = {
    create?: XOR<UserCreateWithoutInstructorInput, UserUncheckedCreateWithoutInstructorInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstructorInput
    upsert?: UserUpsertWithoutInstructorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInstructorInput, UserUpdateWithoutInstructorInput>, UserUncheckedUpdateWithoutInstructorInput>
  }

  export type UserInstructorUpdateOneWithoutInstructorNestedInput = {
    create?: XOR<UserInstructorCreateWithoutInstructorInput, UserInstructorUncheckedCreateWithoutInstructorInput>
    connectOrCreate?: UserInstructorCreateOrConnectWithoutInstructorInput
    upsert?: UserInstructorUpsertWithoutInstructorInput
    disconnect?: UserInstructorWhereInput | boolean
    delete?: UserInstructorWhereInput | boolean
    connect?: UserInstructorWhereUniqueInput
    update?: XOR<XOR<UserInstructorUpdateToOneWithWhereWithoutInstructorInput, UserInstructorUpdateWithoutInstructorInput>, UserInstructorUncheckedUpdateWithoutInstructorInput>
  }

  export type UserInstructorUncheckedUpdateOneWithoutInstructorNestedInput = {
    create?: XOR<UserInstructorCreateWithoutInstructorInput, UserInstructorUncheckedCreateWithoutInstructorInput>
    connectOrCreate?: UserInstructorCreateOrConnectWithoutInstructorInput
    upsert?: UserInstructorUpsertWithoutInstructorInput
    disconnect?: UserInstructorWhereInput | boolean
    delete?: UserInstructorWhereInput | boolean
    connect?: UserInstructorWhereUniqueInput
    update?: XOR<XOR<UserInstructorUpdateToOneWithWhereWithoutInstructorInput, UserInstructorUpdateWithoutInstructorInput>, UserInstructorUncheckedUpdateWithoutInstructorInput>
  }

  export type UserCreateNestedOneWithoutUserInstructorInput = {
    create?: XOR<UserCreateWithoutUserInstructorInput, UserUncheckedCreateWithoutUserInstructorInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserInstructorInput
    connect?: UserWhereUniqueInput
  }

  export type InstructorCreateNestedOneWithoutUserInstructorInput = {
    create?: XOR<InstructorCreateWithoutUserInstructorInput, InstructorUncheckedCreateWithoutUserInstructorInput>
    connectOrCreate?: InstructorCreateOrConnectWithoutUserInstructorInput
    connect?: InstructorWhereUniqueInput
  }

  export type AddLogCreateNestedManyWithoutInstructorInput = {
    create?: XOR<AddLogCreateWithoutInstructorInput, AddLogUncheckedCreateWithoutInstructorInput> | AddLogCreateWithoutInstructorInput[] | AddLogUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: AddLogCreateOrConnectWithoutInstructorInput | AddLogCreateOrConnectWithoutInstructorInput[]
    createMany?: AddLogCreateManyInstructorInputEnvelope
    connect?: AddLogWhereUniqueInput | AddLogWhereUniqueInput[]
  }

  export type AddLogUncheckedCreateNestedManyWithoutInstructorInput = {
    create?: XOR<AddLogCreateWithoutInstructorInput, AddLogUncheckedCreateWithoutInstructorInput> | AddLogCreateWithoutInstructorInput[] | AddLogUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: AddLogCreateOrConnectWithoutInstructorInput | AddLogCreateOrConnectWithoutInstructorInput[]
    createMany?: AddLogCreateManyInstructorInputEnvelope
    connect?: AddLogWhereUniqueInput | AddLogWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutUserInstructorNestedInput = {
    create?: XOR<UserCreateWithoutUserInstructorInput, UserUncheckedCreateWithoutUserInstructorInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserInstructorInput
    upsert?: UserUpsertWithoutUserInstructorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserInstructorInput, UserUpdateWithoutUserInstructorInput>, UserUncheckedUpdateWithoutUserInstructorInput>
  }

  export type InstructorUpdateOneRequiredWithoutUserInstructorNestedInput = {
    create?: XOR<InstructorCreateWithoutUserInstructorInput, InstructorUncheckedCreateWithoutUserInstructorInput>
    connectOrCreate?: InstructorCreateOrConnectWithoutUserInstructorInput
    upsert?: InstructorUpsertWithoutUserInstructorInput
    connect?: InstructorWhereUniqueInput
    update?: XOR<XOR<InstructorUpdateToOneWithWhereWithoutUserInstructorInput, InstructorUpdateWithoutUserInstructorInput>, InstructorUncheckedUpdateWithoutUserInstructorInput>
  }

  export type AddLogUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<AddLogCreateWithoutInstructorInput, AddLogUncheckedCreateWithoutInstructorInput> | AddLogCreateWithoutInstructorInput[] | AddLogUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: AddLogCreateOrConnectWithoutInstructorInput | AddLogCreateOrConnectWithoutInstructorInput[]
    upsert?: AddLogUpsertWithWhereUniqueWithoutInstructorInput | AddLogUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: AddLogCreateManyInstructorInputEnvelope
    set?: AddLogWhereUniqueInput | AddLogWhereUniqueInput[]
    disconnect?: AddLogWhereUniqueInput | AddLogWhereUniqueInput[]
    delete?: AddLogWhereUniqueInput | AddLogWhereUniqueInput[]
    connect?: AddLogWhereUniqueInput | AddLogWhereUniqueInput[]
    update?: AddLogUpdateWithWhereUniqueWithoutInstructorInput | AddLogUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: AddLogUpdateManyWithWhereWithoutInstructorInput | AddLogUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: AddLogScalarWhereInput | AddLogScalarWhereInput[]
  }

  export type AddLogUncheckedUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<AddLogCreateWithoutInstructorInput, AddLogUncheckedCreateWithoutInstructorInput> | AddLogCreateWithoutInstructorInput[] | AddLogUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: AddLogCreateOrConnectWithoutInstructorInput | AddLogCreateOrConnectWithoutInstructorInput[]
    upsert?: AddLogUpsertWithWhereUniqueWithoutInstructorInput | AddLogUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: AddLogCreateManyInstructorInputEnvelope
    set?: AddLogWhereUniqueInput | AddLogWhereUniqueInput[]
    disconnect?: AddLogWhereUniqueInput | AddLogWhereUniqueInput[]
    delete?: AddLogWhereUniqueInput | AddLogWhereUniqueInput[]
    connect?: AddLogWhereUniqueInput | AddLogWhereUniqueInput[]
    update?: AddLogUpdateWithWhereUniqueWithoutInstructorInput | AddLogUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: AddLogUpdateManyWithWhereWithoutInstructorInput | AddLogUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: AddLogScalarWhereInput | AddLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAddLogInput = {
    create?: XOR<UserCreateWithoutAddLogInput, UserUncheckedCreateWithoutAddLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddLogInput
    connect?: UserWhereUniqueInput
  }

  export type UserInstructorCreateNestedOneWithoutAddLogInput = {
    create?: XOR<UserInstructorCreateWithoutAddLogInput, UserInstructorUncheckedCreateWithoutAddLogInput>
    connectOrCreate?: UserInstructorCreateOrConnectWithoutAddLogInput
    connect?: UserInstructorWhereUniqueInput
  }

  export type EnumActionFieldUpdateOperationsInput = {
    set?: $Enums.Action
  }

  export type UserUpdateOneRequiredWithoutAddLogNestedInput = {
    create?: XOR<UserCreateWithoutAddLogInput, UserUncheckedCreateWithoutAddLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddLogInput
    upsert?: UserUpsertWithoutAddLogInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddLogInput, UserUpdateWithoutAddLogInput>, UserUncheckedUpdateWithoutAddLogInput>
  }

  export type UserInstructorUpdateOneRequiredWithoutAddLogNestedInput = {
    create?: XOR<UserInstructorCreateWithoutAddLogInput, UserInstructorUncheckedCreateWithoutAddLogInput>
    connectOrCreate?: UserInstructorCreateOrConnectWithoutAddLogInput
    upsert?: UserInstructorUpsertWithoutAddLogInput
    connect?: UserInstructorWhereUniqueInput
    update?: XOR<XOR<UserInstructorUpdateToOneWithWhereWithoutAddLogInput, UserInstructorUpdateWithoutAddLogInput>, UserInstructorUncheckedUpdateWithoutAddLogInput>
  }

  export type PilotWeatherCreateNestedManyWithoutLocationInput = {
    create?: XOR<PilotWeatherCreateWithoutLocationInput, PilotWeatherUncheckedCreateWithoutLocationInput> | PilotWeatherCreateWithoutLocationInput[] | PilotWeatherUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PilotWeatherCreateOrConnectWithoutLocationInput | PilotWeatherCreateOrConnectWithoutLocationInput[]
    createMany?: PilotWeatherCreateManyLocationInputEnvelope
    connect?: PilotWeatherWhereUniqueInput | PilotWeatherWhereUniqueInput[]
  }

  export type PilotWeatherUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<PilotWeatherCreateWithoutLocationInput, PilotWeatherUncheckedCreateWithoutLocationInput> | PilotWeatherCreateWithoutLocationInput[] | PilotWeatherUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PilotWeatherCreateOrConnectWithoutLocationInput | PilotWeatherCreateOrConnectWithoutLocationInput[]
    createMany?: PilotWeatherCreateManyLocationInputEnvelope
    connect?: PilotWeatherWhereUniqueInput | PilotWeatherWhereUniqueInput[]
  }

  export type PilotWeatherUpdateManyWithoutLocationNestedInput = {
    create?: XOR<PilotWeatherCreateWithoutLocationInput, PilotWeatherUncheckedCreateWithoutLocationInput> | PilotWeatherCreateWithoutLocationInput[] | PilotWeatherUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PilotWeatherCreateOrConnectWithoutLocationInput | PilotWeatherCreateOrConnectWithoutLocationInput[]
    upsert?: PilotWeatherUpsertWithWhereUniqueWithoutLocationInput | PilotWeatherUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: PilotWeatherCreateManyLocationInputEnvelope
    set?: PilotWeatherWhereUniqueInput | PilotWeatherWhereUniqueInput[]
    disconnect?: PilotWeatherWhereUniqueInput | PilotWeatherWhereUniqueInput[]
    delete?: PilotWeatherWhereUniqueInput | PilotWeatherWhereUniqueInput[]
    connect?: PilotWeatherWhereUniqueInput | PilotWeatherWhereUniqueInput[]
    update?: PilotWeatherUpdateWithWhereUniqueWithoutLocationInput | PilotWeatherUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: PilotWeatherUpdateManyWithWhereWithoutLocationInput | PilotWeatherUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: PilotWeatherScalarWhereInput | PilotWeatherScalarWhereInput[]
  }

  export type PilotWeatherUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<PilotWeatherCreateWithoutLocationInput, PilotWeatherUncheckedCreateWithoutLocationInput> | PilotWeatherCreateWithoutLocationInput[] | PilotWeatherUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PilotWeatherCreateOrConnectWithoutLocationInput | PilotWeatherCreateOrConnectWithoutLocationInput[]
    upsert?: PilotWeatherUpsertWithWhereUniqueWithoutLocationInput | PilotWeatherUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: PilotWeatherCreateManyLocationInputEnvelope
    set?: PilotWeatherWhereUniqueInput | PilotWeatherWhereUniqueInput[]
    disconnect?: PilotWeatherWhereUniqueInput | PilotWeatherWhereUniqueInput[]
    delete?: PilotWeatherWhereUniqueInput | PilotWeatherWhereUniqueInput[]
    connect?: PilotWeatherWhereUniqueInput | PilotWeatherWhereUniqueInput[]
    update?: PilotWeatherUpdateWithWhereUniqueWithoutLocationInput | PilotWeatherUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: PilotWeatherUpdateManyWithWhereWithoutLocationInput | PilotWeatherUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: PilotWeatherScalarWhereInput | PilotWeatherScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPilotWeatherInput = {
    create?: XOR<UserCreateWithoutPilotWeatherInput, UserUncheckedCreateWithoutPilotWeatherInput>
    connectOrCreate?: UserCreateOrConnectWithoutPilotWeatherInput
    connect?: UserWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutWeatherInput = {
    create?: XOR<LocationCreateWithoutWeatherInput, LocationUncheckedCreateWithoutWeatherInput>
    connectOrCreate?: LocationCreateOrConnectWithoutWeatherInput
    connect?: LocationWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPilotWeatherNestedInput = {
    create?: XOR<UserCreateWithoutPilotWeatherInput, UserUncheckedCreateWithoutPilotWeatherInput>
    connectOrCreate?: UserCreateOrConnectWithoutPilotWeatherInput
    upsert?: UserUpsertWithoutPilotWeatherInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPilotWeatherInput, UserUpdateWithoutPilotWeatherInput>, UserUncheckedUpdateWithoutPilotWeatherInput>
  }

  export type LocationUpdateOneRequiredWithoutWeatherNestedInput = {
    create?: XOR<LocationCreateWithoutWeatherInput, LocationUncheckedCreateWithoutWeatherInput>
    connectOrCreate?: LocationCreateOrConnectWithoutWeatherInput
    upsert?: LocationUpsertWithoutWeatherInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutWeatherInput, LocationUpdateWithoutWeatherInput>, LocationUncheckedUpdateWithoutWeatherInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumLiceseFilter<$PrismaModel = never> = {
    equals?: $Enums.Licese | EnumLiceseFieldRefInput<$PrismaModel>
    in?: $Enums.Licese[] | ListEnumLiceseFieldRefInput<$PrismaModel>
    notIn?: $Enums.Licese[] | ListEnumLiceseFieldRefInput<$PrismaModel>
    not?: NestedEnumLiceseFilter<$PrismaModel> | $Enums.Licese
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumLiceseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Licese | EnumLiceseFieldRefInput<$PrismaModel>
    in?: $Enums.Licese[] | ListEnumLiceseFieldRefInput<$PrismaModel>
    notIn?: $Enums.Licese[] | ListEnumLiceseFieldRefInput<$PrismaModel>
    not?: NestedEnumLiceseWithAggregatesFilter<$PrismaModel> | $Enums.Licese
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLiceseFilter<$PrismaModel>
    _max?: NestedEnumLiceseFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumActionFilter<$PrismaModel = never> = {
    equals?: $Enums.Action | EnumActionFieldRefInput<$PrismaModel>
    in?: $Enums.Action[] | ListEnumActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Action[] | ListEnumActionFieldRefInput<$PrismaModel>
    not?: NestedEnumActionFilter<$PrismaModel> | $Enums.Action
  }

  export type NestedEnumActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Action | EnumActionFieldRefInput<$PrismaModel>
    in?: $Enums.Action[] | ListEnumActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Action[] | ListEnumActionFieldRefInput<$PrismaModel>
    not?: NestedEnumActionWithAggregatesFilter<$PrismaModel> | $Enums.Action
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionFilter<$PrismaModel>
    _max?: NestedEnumActionFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type InstructorCreateWithoutUserInput = {
    name: string
    email: string
    phone?: string | null
    status?: string | null
    action?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userInstructor?: UserInstructorCreateNestedOneWithoutInstructorInput
  }

  export type InstructorUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    status?: string | null
    action?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userInstructor?: UserInstructorUncheckedCreateNestedOneWithoutInstructorInput
  }

  export type InstructorCreateOrConnectWithoutUserInput = {
    where: InstructorWhereUniqueInput
    create: XOR<InstructorCreateWithoutUserInput, InstructorUncheckedCreateWithoutUserInput>
  }

  export type InstructorCreateManyUserInputEnvelope = {
    data: InstructorCreateManyUserInput | InstructorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AddLogCreateWithoutUserInput = {
    date?: Date | string
    from: string
    to: string
    aircrafttype: string
    tailNumber: string
    flightTime: number
    pictime?: string | null
    dualrcv?: string | null
    daytime: string
    nightime: string
    ifrtime: string
    crossCountry: string
    takeoffs: number
    landings: number
    action?: $Enums.Action
    updatedAt?: Date | string
    createdAt?: Date | string
    instructor: UserInstructorCreateNestedOneWithoutAddLogInput
  }

  export type AddLogUncheckedCreateWithoutUserInput = {
    id?: number
    date?: Date | string
    from: string
    to: string
    aircrafttype: string
    tailNumber: string
    flightTime: number
    pictime?: string | null
    dualrcv?: string | null
    daytime: string
    nightime: string
    ifrtime: string
    crossCountry: string
    takeoffs: number
    landings: number
    instructorId: number
    action?: $Enums.Action
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type AddLogCreateOrConnectWithoutUserInput = {
    where: AddLogWhereUniqueInput
    create: XOR<AddLogCreateWithoutUserInput, AddLogUncheckedCreateWithoutUserInput>
  }

  export type UserNewMemberCreateWithoutUserInput = {
    name: string
    email: string
    subscription?: string | null
    status?: string | null
    action?: string | null
    createdAt?: Date | string
  }

  export type UserNewMemberUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    email: string
    subscription?: string | null
    status?: string | null
    action?: string | null
    createdAt?: Date | string
  }

  export type UserNewMemberCreateOrConnectWithoutUserInput = {
    where: UserNewMemberWhereUniqueInput
    create: XOR<UserNewMemberCreateWithoutUserInput, UserNewMemberUncheckedCreateWithoutUserInput>
  }

  export type PilotWeatherCreateWithoutUserInput = {
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutWeatherInput
  }

  export type PilotWeatherUncheckedCreateWithoutUserInput = {
    id?: number
    locationId: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PilotWeatherCreateOrConnectWithoutUserInput = {
    where: PilotWeatherWhereUniqueInput
    create: XOR<PilotWeatherCreateWithoutUserInput, PilotWeatherUncheckedCreateWithoutUserInput>
  }

  export type UserInstructorCreateWithoutUserInput = {
    name: string
    email: string
    phone?: string | null
    status?: string | null
    action?: string | null
    username?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor: InstructorCreateNestedOneWithoutUserInstructorInput
    addLog?: AddLogCreateNestedManyWithoutInstructorInput
  }

  export type UserInstructorUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    status?: string | null
    action?: string | null
    username?: string | null
    insturctorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addLog?: AddLogUncheckedCreateNestedManyWithoutInstructorInput
  }

  export type UserInstructorCreateOrConnectWithoutUserInput = {
    where: UserInstructorWhereUniqueInput
    create: XOR<UserInstructorCreateWithoutUserInput, UserInstructorUncheckedCreateWithoutUserInput>
  }

  export type InstructorUpsertWithWhereUniqueWithoutUserInput = {
    where: InstructorWhereUniqueInput
    update: XOR<InstructorUpdateWithoutUserInput, InstructorUncheckedUpdateWithoutUserInput>
    create: XOR<InstructorCreateWithoutUserInput, InstructorUncheckedCreateWithoutUserInput>
  }

  export type InstructorUpdateWithWhereUniqueWithoutUserInput = {
    where: InstructorWhereUniqueInput
    data: XOR<InstructorUpdateWithoutUserInput, InstructorUncheckedUpdateWithoutUserInput>
  }

  export type InstructorUpdateManyWithWhereWithoutUserInput = {
    where: InstructorScalarWhereInput
    data: XOR<InstructorUpdateManyMutationInput, InstructorUncheckedUpdateManyWithoutUserInput>
  }

  export type InstructorScalarWhereInput = {
    AND?: InstructorScalarWhereInput | InstructorScalarWhereInput[]
    OR?: InstructorScalarWhereInput[]
    NOT?: InstructorScalarWhereInput | InstructorScalarWhereInput[]
    id?: IntFilter<"Instructor"> | number
    name?: StringFilter<"Instructor"> | string
    email?: StringFilter<"Instructor"> | string
    phone?: StringNullableFilter<"Instructor"> | string | null
    status?: StringNullableFilter<"Instructor"> | string | null
    action?: StringNullableFilter<"Instructor"> | string | null
    userId?: IntFilter<"Instructor"> | number
    createdAt?: DateTimeFilter<"Instructor"> | Date | string
    updatedAt?: DateTimeFilter<"Instructor"> | Date | string
  }

  export type AddLogUpsertWithoutUserInput = {
    update: XOR<AddLogUpdateWithoutUserInput, AddLogUncheckedUpdateWithoutUserInput>
    create: XOR<AddLogCreateWithoutUserInput, AddLogUncheckedCreateWithoutUserInput>
    where?: AddLogWhereInput
  }

  export type AddLogUpdateToOneWithWhereWithoutUserInput = {
    where?: AddLogWhereInput
    data: XOR<AddLogUpdateWithoutUserInput, AddLogUncheckedUpdateWithoutUserInput>
  }

  export type AddLogUpdateWithoutUserInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    aircrafttype?: StringFieldUpdateOperationsInput | string
    tailNumber?: StringFieldUpdateOperationsInput | string
    flightTime?: IntFieldUpdateOperationsInput | number
    pictime?: NullableStringFieldUpdateOperationsInput | string | null
    dualrcv?: NullableStringFieldUpdateOperationsInput | string | null
    daytime?: StringFieldUpdateOperationsInput | string
    nightime?: StringFieldUpdateOperationsInput | string
    ifrtime?: StringFieldUpdateOperationsInput | string
    crossCountry?: StringFieldUpdateOperationsInput | string
    takeoffs?: IntFieldUpdateOperationsInput | number
    landings?: IntFieldUpdateOperationsInput | number
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: UserInstructorUpdateOneRequiredWithoutAddLogNestedInput
  }

  export type AddLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    aircrafttype?: StringFieldUpdateOperationsInput | string
    tailNumber?: StringFieldUpdateOperationsInput | string
    flightTime?: IntFieldUpdateOperationsInput | number
    pictime?: NullableStringFieldUpdateOperationsInput | string | null
    dualrcv?: NullableStringFieldUpdateOperationsInput | string | null
    daytime?: StringFieldUpdateOperationsInput | string
    nightime?: StringFieldUpdateOperationsInput | string
    ifrtime?: StringFieldUpdateOperationsInput | string
    crossCountry?: StringFieldUpdateOperationsInput | string
    takeoffs?: IntFieldUpdateOperationsInput | number
    landings?: IntFieldUpdateOperationsInput | number
    instructorId?: IntFieldUpdateOperationsInput | number
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNewMemberUpsertWithoutUserInput = {
    update: XOR<UserNewMemberUpdateWithoutUserInput, UserNewMemberUncheckedUpdateWithoutUserInput>
    create: XOR<UserNewMemberCreateWithoutUserInput, UserNewMemberUncheckedCreateWithoutUserInput>
    where?: UserNewMemberWhereInput
  }

  export type UserNewMemberUpdateToOneWithWhereWithoutUserInput = {
    where?: UserNewMemberWhereInput
    data: XOR<UserNewMemberUpdateWithoutUserInput, UserNewMemberUncheckedUpdateWithoutUserInput>
  }

  export type UserNewMemberUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNewMemberUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PilotWeatherUpsertWithoutUserInput = {
    update: XOR<PilotWeatherUpdateWithoutUserInput, PilotWeatherUncheckedUpdateWithoutUserInput>
    create: XOR<PilotWeatherCreateWithoutUserInput, PilotWeatherUncheckedCreateWithoutUserInput>
    where?: PilotWeatherWhereInput
  }

  export type PilotWeatherUpdateToOneWithWhereWithoutUserInput = {
    where?: PilotWeatherWhereInput
    data: XOR<PilotWeatherUpdateWithoutUserInput, PilotWeatherUncheckedUpdateWithoutUserInput>
  }

  export type PilotWeatherUpdateWithoutUserInput = {
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutWeatherNestedInput
  }

  export type PilotWeatherUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    locationId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInstructorUpsertWithoutUserInput = {
    update: XOR<UserInstructorUpdateWithoutUserInput, UserInstructorUncheckedUpdateWithoutUserInput>
    create: XOR<UserInstructorCreateWithoutUserInput, UserInstructorUncheckedCreateWithoutUserInput>
    where?: UserInstructorWhereInput
  }

  export type UserInstructorUpdateToOneWithWhereWithoutUserInput = {
    where?: UserInstructorWhereInput
    data: XOR<UserInstructorUpdateWithoutUserInput, UserInstructorUncheckedUpdateWithoutUserInput>
  }

  export type UserInstructorUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: InstructorUpdateOneRequiredWithoutUserInstructorNestedInput
    addLog?: AddLogUpdateManyWithoutInstructorNestedInput
  }

  export type UserInstructorUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    insturctorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addLog?: AddLogUncheckedUpdateManyWithoutInstructorNestedInput
  }

  export type UserCreateWithoutUserNewMemberInput = {
    name: string
    email: string
    password?: string | null
    image?: string | null
    license?: $Enums.Licese
    role?: $Enums.Role
    authProvider?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor?: InstructorCreateNestedManyWithoutUserInput
    addLog?: AddLogCreateNestedOneWithoutUserInput
    pilotWeather?: PilotWeatherCreateNestedOneWithoutUserInput
    userInstructor?: UserInstructorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserNewMemberInput = {
    id?: number
    name: string
    email: string
    password?: string | null
    image?: string | null
    license?: $Enums.Licese
    role?: $Enums.Role
    authProvider?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    addLog?: AddLogUncheckedCreateNestedOneWithoutUserInput
    pilotWeather?: PilotWeatherUncheckedCreateNestedOneWithoutUserInput
    userInstructor?: UserInstructorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserNewMemberInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserNewMemberInput, UserUncheckedCreateWithoutUserNewMemberInput>
  }

  export type UserUpsertWithoutUserNewMemberInput = {
    update: XOR<UserUpdateWithoutUserNewMemberInput, UserUncheckedUpdateWithoutUserNewMemberInput>
    create: XOR<UserCreateWithoutUserNewMemberInput, UserUncheckedCreateWithoutUserNewMemberInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserNewMemberInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserNewMemberInput, UserUncheckedUpdateWithoutUserNewMemberInput>
  }

  export type UserUpdateWithoutUserNewMemberInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    license?: EnumLiceseFieldUpdateOperationsInput | $Enums.Licese
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: InstructorUpdateManyWithoutUserNestedInput
    addLog?: AddLogUpdateOneWithoutUserNestedInput
    pilotWeather?: PilotWeatherUpdateOneWithoutUserNestedInput
    userInstructor?: UserInstructorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserNewMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    license?: EnumLiceseFieldUpdateOperationsInput | $Enums.Licese
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    addLog?: AddLogUncheckedUpdateOneWithoutUserNestedInput
    pilotWeather?: PilotWeatherUncheckedUpdateOneWithoutUserNestedInput
    userInstructor?: UserInstructorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutInstructorInput = {
    name: string
    email: string
    password?: string | null
    image?: string | null
    license?: $Enums.Licese
    role?: $Enums.Role
    authProvider?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    addLog?: AddLogCreateNestedOneWithoutUserInput
    userNewMember?: UserNewMemberCreateNestedOneWithoutUserInput
    pilotWeather?: PilotWeatherCreateNestedOneWithoutUserInput
    userInstructor?: UserInstructorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInstructorInput = {
    id?: number
    name: string
    email: string
    password?: string | null
    image?: string | null
    license?: $Enums.Licese
    role?: $Enums.Role
    authProvider?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    addLog?: AddLogUncheckedCreateNestedOneWithoutUserInput
    userNewMember?: UserNewMemberUncheckedCreateNestedOneWithoutUserInput
    pilotWeather?: PilotWeatherUncheckedCreateNestedOneWithoutUserInput
    userInstructor?: UserInstructorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInstructorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInstructorInput, UserUncheckedCreateWithoutInstructorInput>
  }

  export type UserInstructorCreateWithoutInstructorInput = {
    name: string
    email: string
    phone?: string | null
    status?: string | null
    action?: string | null
    username?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserInstructorInput
    addLog?: AddLogCreateNestedManyWithoutInstructorInput
  }

  export type UserInstructorUncheckedCreateWithoutInstructorInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    status?: string | null
    action?: string | null
    username?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addLog?: AddLogUncheckedCreateNestedManyWithoutInstructorInput
  }

  export type UserInstructorCreateOrConnectWithoutInstructorInput = {
    where: UserInstructorWhereUniqueInput
    create: XOR<UserInstructorCreateWithoutInstructorInput, UserInstructorUncheckedCreateWithoutInstructorInput>
  }

  export type UserUpsertWithoutInstructorInput = {
    update: XOR<UserUpdateWithoutInstructorInput, UserUncheckedUpdateWithoutInstructorInput>
    create: XOR<UserCreateWithoutInstructorInput, UserUncheckedCreateWithoutInstructorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInstructorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInstructorInput, UserUncheckedUpdateWithoutInstructorInput>
  }

  export type UserUpdateWithoutInstructorInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    license?: EnumLiceseFieldUpdateOperationsInput | $Enums.Licese
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addLog?: AddLogUpdateOneWithoutUserNestedInput
    userNewMember?: UserNewMemberUpdateOneWithoutUserNestedInput
    pilotWeather?: PilotWeatherUpdateOneWithoutUserNestedInput
    userInstructor?: UserInstructorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInstructorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    license?: EnumLiceseFieldUpdateOperationsInput | $Enums.Licese
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addLog?: AddLogUncheckedUpdateOneWithoutUserNestedInput
    userNewMember?: UserNewMemberUncheckedUpdateOneWithoutUserNestedInput
    pilotWeather?: PilotWeatherUncheckedUpdateOneWithoutUserNestedInput
    userInstructor?: UserInstructorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserInstructorUpsertWithoutInstructorInput = {
    update: XOR<UserInstructorUpdateWithoutInstructorInput, UserInstructorUncheckedUpdateWithoutInstructorInput>
    create: XOR<UserInstructorCreateWithoutInstructorInput, UserInstructorUncheckedCreateWithoutInstructorInput>
    where?: UserInstructorWhereInput
  }

  export type UserInstructorUpdateToOneWithWhereWithoutInstructorInput = {
    where?: UserInstructorWhereInput
    data: XOR<UserInstructorUpdateWithoutInstructorInput, UserInstructorUncheckedUpdateWithoutInstructorInput>
  }

  export type UserInstructorUpdateWithoutInstructorInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserInstructorNestedInput
    addLog?: AddLogUpdateManyWithoutInstructorNestedInput
  }

  export type UserInstructorUncheckedUpdateWithoutInstructorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addLog?: AddLogUncheckedUpdateManyWithoutInstructorNestedInput
  }

  export type UserCreateWithoutUserInstructorInput = {
    name: string
    email: string
    password?: string | null
    image?: string | null
    license?: $Enums.Licese
    role?: $Enums.Role
    authProvider?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor?: InstructorCreateNestedManyWithoutUserInput
    addLog?: AddLogCreateNestedOneWithoutUserInput
    userNewMember?: UserNewMemberCreateNestedOneWithoutUserInput
    pilotWeather?: PilotWeatherCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserInstructorInput = {
    id?: number
    name: string
    email: string
    password?: string | null
    image?: string | null
    license?: $Enums.Licese
    role?: $Enums.Role
    authProvider?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    addLog?: AddLogUncheckedCreateNestedOneWithoutUserInput
    userNewMember?: UserNewMemberUncheckedCreateNestedOneWithoutUserInput
    pilotWeather?: PilotWeatherUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserInstructorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserInstructorInput, UserUncheckedCreateWithoutUserInstructorInput>
  }

  export type InstructorCreateWithoutUserInstructorInput = {
    name: string
    email: string
    phone?: string | null
    status?: string | null
    action?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInstructorInput
  }

  export type InstructorUncheckedCreateWithoutUserInstructorInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    status?: string | null
    action?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstructorCreateOrConnectWithoutUserInstructorInput = {
    where: InstructorWhereUniqueInput
    create: XOR<InstructorCreateWithoutUserInstructorInput, InstructorUncheckedCreateWithoutUserInstructorInput>
  }

  export type AddLogCreateWithoutInstructorInput = {
    date?: Date | string
    from: string
    to: string
    aircrafttype: string
    tailNumber: string
    flightTime: number
    pictime?: string | null
    dualrcv?: string | null
    daytime: string
    nightime: string
    ifrtime: string
    crossCountry: string
    takeoffs: number
    landings: number
    action?: $Enums.Action
    updatedAt?: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAddLogInput
  }

  export type AddLogUncheckedCreateWithoutInstructorInput = {
    id?: number
    date?: Date | string
    from: string
    to: string
    aircrafttype: string
    tailNumber: string
    flightTime: number
    pictime?: string | null
    dualrcv?: string | null
    daytime: string
    nightime: string
    ifrtime: string
    crossCountry: string
    takeoffs: number
    landings: number
    userId: number
    action?: $Enums.Action
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type AddLogCreateOrConnectWithoutInstructorInput = {
    where: AddLogWhereUniqueInput
    create: XOR<AddLogCreateWithoutInstructorInput, AddLogUncheckedCreateWithoutInstructorInput>
  }

  export type AddLogCreateManyInstructorInputEnvelope = {
    data: AddLogCreateManyInstructorInput | AddLogCreateManyInstructorInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutUserInstructorInput = {
    update: XOR<UserUpdateWithoutUserInstructorInput, UserUncheckedUpdateWithoutUserInstructorInput>
    create: XOR<UserCreateWithoutUserInstructorInput, UserUncheckedCreateWithoutUserInstructorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserInstructorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserInstructorInput, UserUncheckedUpdateWithoutUserInstructorInput>
  }

  export type UserUpdateWithoutUserInstructorInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    license?: EnumLiceseFieldUpdateOperationsInput | $Enums.Licese
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: InstructorUpdateManyWithoutUserNestedInput
    addLog?: AddLogUpdateOneWithoutUserNestedInput
    userNewMember?: UserNewMemberUpdateOneWithoutUserNestedInput
    pilotWeather?: PilotWeatherUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserInstructorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    license?: EnumLiceseFieldUpdateOperationsInput | $Enums.Licese
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    addLog?: AddLogUncheckedUpdateOneWithoutUserNestedInput
    userNewMember?: UserNewMemberUncheckedUpdateOneWithoutUserNestedInput
    pilotWeather?: PilotWeatherUncheckedUpdateOneWithoutUserNestedInput
  }

  export type InstructorUpsertWithoutUserInstructorInput = {
    update: XOR<InstructorUpdateWithoutUserInstructorInput, InstructorUncheckedUpdateWithoutUserInstructorInput>
    create: XOR<InstructorCreateWithoutUserInstructorInput, InstructorUncheckedCreateWithoutUserInstructorInput>
    where?: InstructorWhereInput
  }

  export type InstructorUpdateToOneWithWhereWithoutUserInstructorInput = {
    where?: InstructorWhereInput
    data: XOR<InstructorUpdateWithoutUserInstructorInput, InstructorUncheckedUpdateWithoutUserInstructorInput>
  }

  export type InstructorUpdateWithoutUserInstructorInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInstructorNestedInput
  }

  export type InstructorUncheckedUpdateWithoutUserInstructorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddLogUpsertWithWhereUniqueWithoutInstructorInput = {
    where: AddLogWhereUniqueInput
    update: XOR<AddLogUpdateWithoutInstructorInput, AddLogUncheckedUpdateWithoutInstructorInput>
    create: XOR<AddLogCreateWithoutInstructorInput, AddLogUncheckedCreateWithoutInstructorInput>
  }

  export type AddLogUpdateWithWhereUniqueWithoutInstructorInput = {
    where: AddLogWhereUniqueInput
    data: XOR<AddLogUpdateWithoutInstructorInput, AddLogUncheckedUpdateWithoutInstructorInput>
  }

  export type AddLogUpdateManyWithWhereWithoutInstructorInput = {
    where: AddLogScalarWhereInput
    data: XOR<AddLogUpdateManyMutationInput, AddLogUncheckedUpdateManyWithoutInstructorInput>
  }

  export type AddLogScalarWhereInput = {
    AND?: AddLogScalarWhereInput | AddLogScalarWhereInput[]
    OR?: AddLogScalarWhereInput[]
    NOT?: AddLogScalarWhereInput | AddLogScalarWhereInput[]
    id?: IntFilter<"AddLog"> | number
    date?: DateTimeFilter<"AddLog"> | Date | string
    from?: StringFilter<"AddLog"> | string
    to?: StringFilter<"AddLog"> | string
    aircrafttype?: StringFilter<"AddLog"> | string
    tailNumber?: StringFilter<"AddLog"> | string
    flightTime?: IntFilter<"AddLog"> | number
    pictime?: StringNullableFilter<"AddLog"> | string | null
    dualrcv?: StringNullableFilter<"AddLog"> | string | null
    daytime?: StringFilter<"AddLog"> | string
    nightime?: StringFilter<"AddLog"> | string
    ifrtime?: StringFilter<"AddLog"> | string
    crossCountry?: StringFilter<"AddLog"> | string
    takeoffs?: IntFilter<"AddLog"> | number
    landings?: IntFilter<"AddLog"> | number
    userId?: IntFilter<"AddLog"> | number
    instructorId?: IntFilter<"AddLog"> | number
    action?: EnumActionFilter<"AddLog"> | $Enums.Action
    updatedAt?: DateTimeFilter<"AddLog"> | Date | string
    createdAt?: DateTimeFilter<"AddLog"> | Date | string
  }

  export type UserCreateWithoutAddLogInput = {
    name: string
    email: string
    password?: string | null
    image?: string | null
    license?: $Enums.Licese
    role?: $Enums.Role
    authProvider?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor?: InstructorCreateNestedManyWithoutUserInput
    userNewMember?: UserNewMemberCreateNestedOneWithoutUserInput
    pilotWeather?: PilotWeatherCreateNestedOneWithoutUserInput
    userInstructor?: UserInstructorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAddLogInput = {
    id?: number
    name: string
    email: string
    password?: string | null
    image?: string | null
    license?: $Enums.Licese
    role?: $Enums.Role
    authProvider?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    userNewMember?: UserNewMemberUncheckedCreateNestedOneWithoutUserInput
    pilotWeather?: PilotWeatherUncheckedCreateNestedOneWithoutUserInput
    userInstructor?: UserInstructorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAddLogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddLogInput, UserUncheckedCreateWithoutAddLogInput>
  }

  export type UserInstructorCreateWithoutAddLogInput = {
    name: string
    email: string
    phone?: string | null
    status?: string | null
    action?: string | null
    username?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserInstructorInput
    instructor: InstructorCreateNestedOneWithoutUserInstructorInput
  }

  export type UserInstructorUncheckedCreateWithoutAddLogInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    status?: string | null
    action?: string | null
    username?: string | null
    userId: number
    insturctorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserInstructorCreateOrConnectWithoutAddLogInput = {
    where: UserInstructorWhereUniqueInput
    create: XOR<UserInstructorCreateWithoutAddLogInput, UserInstructorUncheckedCreateWithoutAddLogInput>
  }

  export type UserUpsertWithoutAddLogInput = {
    update: XOR<UserUpdateWithoutAddLogInput, UserUncheckedUpdateWithoutAddLogInput>
    create: XOR<UserCreateWithoutAddLogInput, UserUncheckedCreateWithoutAddLogInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddLogInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddLogInput, UserUncheckedUpdateWithoutAddLogInput>
  }

  export type UserUpdateWithoutAddLogInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    license?: EnumLiceseFieldUpdateOperationsInput | $Enums.Licese
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: InstructorUpdateManyWithoutUserNestedInput
    userNewMember?: UserNewMemberUpdateOneWithoutUserNestedInput
    pilotWeather?: PilotWeatherUpdateOneWithoutUserNestedInput
    userInstructor?: UserInstructorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAddLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    license?: EnumLiceseFieldUpdateOperationsInput | $Enums.Licese
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    userNewMember?: UserNewMemberUncheckedUpdateOneWithoutUserNestedInput
    pilotWeather?: PilotWeatherUncheckedUpdateOneWithoutUserNestedInput
    userInstructor?: UserInstructorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserInstructorUpsertWithoutAddLogInput = {
    update: XOR<UserInstructorUpdateWithoutAddLogInput, UserInstructorUncheckedUpdateWithoutAddLogInput>
    create: XOR<UserInstructorCreateWithoutAddLogInput, UserInstructorUncheckedCreateWithoutAddLogInput>
    where?: UserInstructorWhereInput
  }

  export type UserInstructorUpdateToOneWithWhereWithoutAddLogInput = {
    where?: UserInstructorWhereInput
    data: XOR<UserInstructorUpdateWithoutAddLogInput, UserInstructorUncheckedUpdateWithoutAddLogInput>
  }

  export type UserInstructorUpdateWithoutAddLogInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserInstructorNestedInput
    instructor?: InstructorUpdateOneRequiredWithoutUserInstructorNestedInput
  }

  export type UserInstructorUncheckedUpdateWithoutAddLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    insturctorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PilotWeatherCreateWithoutLocationInput = {
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPilotWeatherInput
  }

  export type PilotWeatherUncheckedCreateWithoutLocationInput = {
    id?: number
    userId: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PilotWeatherCreateOrConnectWithoutLocationInput = {
    where: PilotWeatherWhereUniqueInput
    create: XOR<PilotWeatherCreateWithoutLocationInput, PilotWeatherUncheckedCreateWithoutLocationInput>
  }

  export type PilotWeatherCreateManyLocationInputEnvelope = {
    data: PilotWeatherCreateManyLocationInput | PilotWeatherCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type PilotWeatherUpsertWithWhereUniqueWithoutLocationInput = {
    where: PilotWeatherWhereUniqueInput
    update: XOR<PilotWeatherUpdateWithoutLocationInput, PilotWeatherUncheckedUpdateWithoutLocationInput>
    create: XOR<PilotWeatherCreateWithoutLocationInput, PilotWeatherUncheckedCreateWithoutLocationInput>
  }

  export type PilotWeatherUpdateWithWhereUniqueWithoutLocationInput = {
    where: PilotWeatherWhereUniqueInput
    data: XOR<PilotWeatherUpdateWithoutLocationInput, PilotWeatherUncheckedUpdateWithoutLocationInput>
  }

  export type PilotWeatherUpdateManyWithWhereWithoutLocationInput = {
    where: PilotWeatherScalarWhereInput
    data: XOR<PilotWeatherUpdateManyMutationInput, PilotWeatherUncheckedUpdateManyWithoutLocationInput>
  }

  export type PilotWeatherScalarWhereInput = {
    AND?: PilotWeatherScalarWhereInput | PilotWeatherScalarWhereInput[]
    OR?: PilotWeatherScalarWhereInput[]
    NOT?: PilotWeatherScalarWhereInput | PilotWeatherScalarWhereInput[]
    id?: IntFilter<"PilotWeather"> | number
    userId?: IntFilter<"PilotWeather"> | number
    locationId?: StringFilter<"PilotWeather"> | string
    data?: JsonFilter<"PilotWeather">
    createdAt?: DateTimeFilter<"PilotWeather"> | Date | string
    updatedAt?: DateTimeFilter<"PilotWeather"> | Date | string
  }

  export type UserCreateWithoutPilotWeatherInput = {
    name: string
    email: string
    password?: string | null
    image?: string | null
    license?: $Enums.Licese
    role?: $Enums.Role
    authProvider?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor?: InstructorCreateNestedManyWithoutUserInput
    addLog?: AddLogCreateNestedOneWithoutUserInput
    userNewMember?: UserNewMemberCreateNestedOneWithoutUserInput
    userInstructor?: UserInstructorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPilotWeatherInput = {
    id?: number
    name: string
    email: string
    password?: string | null
    image?: string | null
    license?: $Enums.Licese
    role?: $Enums.Role
    authProvider?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    addLog?: AddLogUncheckedCreateNestedOneWithoutUserInput
    userNewMember?: UserNewMemberUncheckedCreateNestedOneWithoutUserInput
    userInstructor?: UserInstructorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPilotWeatherInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPilotWeatherInput, UserUncheckedCreateWithoutPilotWeatherInput>
  }

  export type LocationCreateWithoutWeatherInput = {
    id?: string
    name: string
  }

  export type LocationUncheckedCreateWithoutWeatherInput = {
    id?: string
    name: string
  }

  export type LocationCreateOrConnectWithoutWeatherInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutWeatherInput, LocationUncheckedCreateWithoutWeatherInput>
  }

  export type UserUpsertWithoutPilotWeatherInput = {
    update: XOR<UserUpdateWithoutPilotWeatherInput, UserUncheckedUpdateWithoutPilotWeatherInput>
    create: XOR<UserCreateWithoutPilotWeatherInput, UserUncheckedCreateWithoutPilotWeatherInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPilotWeatherInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPilotWeatherInput, UserUncheckedUpdateWithoutPilotWeatherInput>
  }

  export type UserUpdateWithoutPilotWeatherInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    license?: EnumLiceseFieldUpdateOperationsInput | $Enums.Licese
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: InstructorUpdateManyWithoutUserNestedInput
    addLog?: AddLogUpdateOneWithoutUserNestedInput
    userNewMember?: UserNewMemberUpdateOneWithoutUserNestedInput
    userInstructor?: UserInstructorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPilotWeatherInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    license?: EnumLiceseFieldUpdateOperationsInput | $Enums.Licese
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    addLog?: AddLogUncheckedUpdateOneWithoutUserNestedInput
    userNewMember?: UserNewMemberUncheckedUpdateOneWithoutUserNestedInput
    userInstructor?: UserInstructorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type LocationUpsertWithoutWeatherInput = {
    update: XOR<LocationUpdateWithoutWeatherInput, LocationUncheckedUpdateWithoutWeatherInput>
    create: XOR<LocationCreateWithoutWeatherInput, LocationUncheckedCreateWithoutWeatherInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutWeatherInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutWeatherInput, LocationUncheckedUpdateWithoutWeatherInput>
  }

  export type LocationUpdateWithoutWeatherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LocationUncheckedUpdateWithoutWeatherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InstructorCreateManyUserInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    status?: string | null
    action?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstructorUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userInstructor?: UserInstructorUpdateOneWithoutInstructorNestedInput
  }

  export type InstructorUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userInstructor?: UserInstructorUncheckedUpdateOneWithoutInstructorNestedInput
  }

  export type InstructorUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddLogCreateManyInstructorInput = {
    id?: number
    date?: Date | string
    from: string
    to: string
    aircrafttype: string
    tailNumber: string
    flightTime: number
    pictime?: string | null
    dualrcv?: string | null
    daytime: string
    nightime: string
    ifrtime: string
    crossCountry: string
    takeoffs: number
    landings: number
    userId: number
    action?: $Enums.Action
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type AddLogUpdateWithoutInstructorInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    aircrafttype?: StringFieldUpdateOperationsInput | string
    tailNumber?: StringFieldUpdateOperationsInput | string
    flightTime?: IntFieldUpdateOperationsInput | number
    pictime?: NullableStringFieldUpdateOperationsInput | string | null
    dualrcv?: NullableStringFieldUpdateOperationsInput | string | null
    daytime?: StringFieldUpdateOperationsInput | string
    nightime?: StringFieldUpdateOperationsInput | string
    ifrtime?: StringFieldUpdateOperationsInput | string
    crossCountry?: StringFieldUpdateOperationsInput | string
    takeoffs?: IntFieldUpdateOperationsInput | number
    landings?: IntFieldUpdateOperationsInput | number
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAddLogNestedInput
  }

  export type AddLogUncheckedUpdateWithoutInstructorInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    aircrafttype?: StringFieldUpdateOperationsInput | string
    tailNumber?: StringFieldUpdateOperationsInput | string
    flightTime?: IntFieldUpdateOperationsInput | number
    pictime?: NullableStringFieldUpdateOperationsInput | string | null
    dualrcv?: NullableStringFieldUpdateOperationsInput | string | null
    daytime?: StringFieldUpdateOperationsInput | string
    nightime?: StringFieldUpdateOperationsInput | string
    ifrtime?: StringFieldUpdateOperationsInput | string
    crossCountry?: StringFieldUpdateOperationsInput | string
    takeoffs?: IntFieldUpdateOperationsInput | number
    landings?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddLogUncheckedUpdateManyWithoutInstructorInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    aircrafttype?: StringFieldUpdateOperationsInput | string
    tailNumber?: StringFieldUpdateOperationsInput | string
    flightTime?: IntFieldUpdateOperationsInput | number
    pictime?: NullableStringFieldUpdateOperationsInput | string | null
    dualrcv?: NullableStringFieldUpdateOperationsInput | string | null
    daytime?: StringFieldUpdateOperationsInput | string
    nightime?: StringFieldUpdateOperationsInput | string
    ifrtime?: StringFieldUpdateOperationsInput | string
    crossCountry?: StringFieldUpdateOperationsInput | string
    takeoffs?: IntFieldUpdateOperationsInput | number
    landings?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PilotWeatherCreateManyLocationInput = {
    id?: number
    userId: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PilotWeatherUpdateWithoutLocationInput = {
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPilotWeatherNestedInput
  }

  export type PilotWeatherUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PilotWeatherUncheckedUpdateManyWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}